{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ECE 2400 / ENGRD 2140 Computer Systems Programming Docs Public Course Website: http://www.csl.cornell.edu/courses/ece2400 This is the ECE 2400 / ENGRD 2140 Computer Systems Programming documentation site. It includes topic notes, discussion section handouts, tutorials, and programming assignment handouts. If you find any bugs or errors with this documentation, please post on Piazza or feel free to create a pull request in the corresponding documentation repo .","title":"Home"},{"location":"#ece-2400-engrd-2140-computer-systems-programming-docs","text":"Public Course Website: http://www.csl.cornell.edu/courses/ece2400 This is the ECE 2400 / ENGRD 2140 Computer Systems Programming documentation site. It includes topic notes, discussion section handouts, tutorials, and programming assignment handouts. If you find any bugs or errors with this documentation, please post on Piazza or feel free to create a pull request in the corresponding documentation repo .","title":"ECE 2400 / ENGRD 2140 Computer Systems Programming Docs"},{"location":"ece2400-T01-intro-c-notes/","text":"Topic 1: Introduction to C The first few programming assignments for this course will use the C programming language. This tutorial begins by briefly reviewing the basics of C functions, conditional statements, and iteration statements. The tutorial then discusses the C preprocessor before describing how to compile and execute both single-file and multi-file C programs using the command line. All of the tools are installed and available on the ecelinux machines. This tutorial assumes that students have completed the Linux and Git tutorials. We strongly recommend students also read Chapters 1-6 in the course text book, ``All of Programming,'' by A. Hilton and A. Bracy (2015). Chapters 5-6 are particularly relevant since they discuss the general process of compiling, testing, and debugging C programs. To follow along with the tutorial, access the course computing resources, and type the commands without the % character (for the bash prompt). In addition to working through the commands in the tutorial, you should also try the more open-ended tasks marked To-Do On Your Own . Before you begin, make sure that you have sourced the setup-ece2400.sh script or that you have added it to your .bashrc script, which will then source the script every time you login. Sourcing the setup script sets up the environment required for this class. You should start by forking the tutorial repository on GitHub. Go to the GitHub page for the tutorial repository located here: https://github.com/cornell-ece2400/ece2400-tut3-c . Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a new repository in your account: https://github.com/ githubid /ece2400-tut3-c Where githubid is your GitHub username on github.com . Now access an ecelinux machine and clone your copy of the tutorial repository as follows: 1 2 3 4 5 6 % source setup-ece2400.sh % mkdir -p ${ HOME } /ece2400 % cd ${ HOME } /ece2400 % git clone https://github.com/ githubid /ece2400-tut3-c.git tut3 % cd tut3 % TUTROOT = ${ PWD } Note It should be possible to experiment with this tutorial even if you are not enrolled in the course and/or do not have access to the course computing resources. All of the code for the tutorial is located on GitHub. You will not use the setup-ece2400.sh script, and your specific environment may be different from what is assumed in this tutorial. 1. C Basics C is a programming language that has a long history of use in computer systems programming . Computer systems programming involves developing software to connect the low-level computer hardware to high-level, user-facing application software and usually requires careful consideration of performance and resource constraints. Examples of computer systems software include compilers, operating systems, databases, numerical libraries, and embedded controllers. C was developed in the early 1970s at Bell Laboratories by Ken Thompson, Dennis Ritchie, and many others. C was originally developed for the purposes of writing an early version of the Unix operating system. The Linux operating system which you learned about in the first tutorial was inspired by these original versions of Unix, and the Linux kernel is also written in C. C provides a nice balance between high-level abstractions for productive software development and low-level control over the hardware, and thus it remains one of the primary languages chosen by computer systems programmers. In this section, we will briefly review some of the basic syntax and semantics of C. 1.1. Using Compiler Explorer and Repl.it to Experiment with C Programs Compiling a C program can be challenging, since it usually involves multiple command line tools and steps. So to get started, we will be using two online tools which will enable us to quickly experiment with small C programs. Later in the tutorial, we will see how to compile, build, test, debug, and evaluate both small and large C programs on the ecelinux machines. The first online tool is called Compiler Explorer, and it is accessed through the following link: https://godbolt.org . You can enter simple C functions in the left text box, and then Compiler Explorer will display the corresponding machine instructions (i.e., assembly code) in the right text box. This is a great way to quickly use your browser to see the connection between C programs and the low-level computer hardware. Compiler Explorer color codes the C program and the machine instructions, so it is possible to see which C statements compile into which machine instructions. There is a drop-down menu to choose different compilers. Choosing x86-64 gcc 7.2 roughly corresponds to the compiler we will be using on the ecelinux machines which is based on the Intel x86-64 instruction set. Choosing MIPS gcc 5.4 (el) roughly corresponds to the compiler used in ECE 2300 which is based on the MIPS instruction set. There is also a text box where you can enter various compiler command line options. The second online tool is called Repl.it, and it is accessed through the following link: http://repl.it . You can create a new \"repl\" by choosing the C programming language. You can enter simple C programs in the left text box. Clicking on the run button will first compile the C program into an executable binary, and then run this executable binary. This is a great way to quickly experiment with C programs in your browser. The output of running the program is shown in the right text box. C Functions The definition for a simple function to calculate the average of two integers is shown below. 1 2 3 4 5 int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } A C function definition specifies a named parameterized sequence of statements. C function definitions have four parts: a function name (e.g., avg on Line 1; a function parameter list (e.g., int x, int y on Line 1); a function return type (e.g., int at the beginning of Line 1); and the function body (e.g. Lines 2-5). In this tutorial, we will only use the int type for variables, but the C language supports a rich selection of different types for representing integer numbers, real numbers, characters, pointers, and composite structures. A function creates a new block and all variable declarations within the function are local to that scope. Line 3 is a variable initialization statement which first creates a new variable of type int named sum and then initializes this variable with the value of the expression x+y . Remember that all C statements end in a semicolon ( ; ). Line 4 is a return statement which causes the function to return the value of the corresponding expression (e.g., sum/2 ). Calling a C function involves setting the parameters in the parameter list, executing the sequence of statements in the function body, and then returning the return value. A C function call is just another kind of expression which evaluates to the function's return value. Enter the avg function into Compiler Explorer and take a look at the corresponding machine instructions for the Intel x86-64 instruction set. The avg function compiles to 15 machine instructions. In this course, you are not responsible for understanding these machine instructions, but it is still very important to recognize that C programs usually map relatively directly to machine instructions. Notice that the statement on Line 3 maps to four machine instructions (the C statement and the machine instructions are all colored yellow) including an add instruction. If you right click on one of the Intel x86-64 machine instructions and choose View Asm Doc , Compiler Explorer will display a detailed description of that machine instruction. Try finding out more about the add instruction. This instruction directly corresponds to the + operator in the avg function; this direct mapping from high-level syntax to low-level machine instructions is one of the key features of C. The + operator in a language such as Python or MATLAB would eventually correspond to hundreds of machine instructions! Enter -O3 into the Compiler options... text box and press return. This option tells the compiler to apply various optimizations to improve the performance of the compiled machine instructions. The avg function now compiles to six machine instructions, and we can see that Line 3 now maps to a single machine instruction (the C statement and the machine instruction are both are colored green). Even without understanding the details of these machine instructions, it should be obvious that reducing the number of machine instructions from 15 to six should improve performance. The definition for a simple main function to call the avg function and then print its result is shown below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include stdio.h int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( average of %d and %d is %d \\n , a , b , c , ); return 0 ; } Recall that the main function is special. The main function is always where program execution starts; in other words, the main function is always the first function to be called in any C program. Lines 11-13 are variable initialization statements. Line 13 calls the avg function with the values in variables a and b , and then the return value is used to initialize variable c . Line 14 calls the printf function to display text on the screen. The printf function is defined in the C standard library which is usually included along with every C compiler. More specifically, the printf function declaration is in a separate header file which is included on Line 1 using the C preprocessor. We will learn more about the C preprocessor later in this tutorial. The printf function always takes a format string as the first parameter, and then takes a variable number of parameters that are evaluated and substituted into the format string. The format string includes format specifiers (i.e., special codes) to indicate where to substitute these values. In this example, we are using the %d format specifier to indicate that we would like to substitute an integer into the format string. The format string can also include other special codes; for example, this format string includes a newline special code ( \\n ) which results in a line break. The return value of the main function is used as the exit status of the program; this is a way for a C program to tell the operating system whether or not the program ended successfully (by returning zero) or something went wrong (by returning a non-zero value). Enter the avg and main functions into Repl.it and then use the run button to compile and execute this C program. Try initializing a to 10 and b to 15. The average of these two integers is 12.5, but our program currently does not support arithmetic on non-integer values. In this case, the division operator (i.e., / ) truncates the result by always rounding towards zero. Quickly experimenting with small C programs can help illustrate subtle issues in C syntax and semantics. Question Write a simple function named avg3 to average three integers. Use Compiler Explorer to examine the corresponding machine instructions and identify how the + operators in the C program maps to add machine instructions. Use Repl.it to compile and execute a program with the avg3 function and a main function to call the average function and print its result. Experiment with averaging negative numbers, especially negative numbers where ideally the result would not be an integer (e.g., -7 , -5 , and -4 ). Problem 1.1: Writing an avg3 function Here is a programming question","title":"ece2400 T01 intro c notes"},{"location":"ece2400-T01-intro-c-notes/#topic-1-introduction-to-c","text":"The first few programming assignments for this course will use the C programming language. This tutorial begins by briefly reviewing the basics of C functions, conditional statements, and iteration statements. The tutorial then discusses the C preprocessor before describing how to compile and execute both single-file and multi-file C programs using the command line. All of the tools are installed and available on the ecelinux machines. This tutorial assumes that students have completed the Linux and Git tutorials. We strongly recommend students also read Chapters 1-6 in the course text book, ``All of Programming,'' by A. Hilton and A. Bracy (2015). Chapters 5-6 are particularly relevant since they discuss the general process of compiling, testing, and debugging C programs. To follow along with the tutorial, access the course computing resources, and type the commands without the % character (for the bash prompt). In addition to working through the commands in the tutorial, you should also try the more open-ended tasks marked To-Do On Your Own . Before you begin, make sure that you have sourced the setup-ece2400.sh script or that you have added it to your .bashrc script, which will then source the script every time you login. Sourcing the setup script sets up the environment required for this class. You should start by forking the tutorial repository on GitHub. Go to the GitHub page for the tutorial repository located here: https://github.com/cornell-ece2400/ece2400-tut3-c . Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a new repository in your account: https://github.com/ githubid /ece2400-tut3-c Where githubid is your GitHub username on github.com . Now access an ecelinux machine and clone your copy of the tutorial repository as follows: 1 2 3 4 5 6 % source setup-ece2400.sh % mkdir -p ${ HOME } /ece2400 % cd ${ HOME } /ece2400 % git clone https://github.com/ githubid /ece2400-tut3-c.git tut3 % cd tut3 % TUTROOT = ${ PWD } Note It should be possible to experiment with this tutorial even if you are not enrolled in the course and/or do not have access to the course computing resources. All of the code for the tutorial is located on GitHub. You will not use the setup-ece2400.sh script, and your specific environment may be different from what is assumed in this tutorial.","title":"Topic 1: Introduction to C"},{"location":"ece2400-T01-intro-c-notes/#1-c-basics","text":"C is a programming language that has a long history of use in computer systems programming . Computer systems programming involves developing software to connect the low-level computer hardware to high-level, user-facing application software and usually requires careful consideration of performance and resource constraints. Examples of computer systems software include compilers, operating systems, databases, numerical libraries, and embedded controllers. C was developed in the early 1970s at Bell Laboratories by Ken Thompson, Dennis Ritchie, and many others. C was originally developed for the purposes of writing an early version of the Unix operating system. The Linux operating system which you learned about in the first tutorial was inspired by these original versions of Unix, and the Linux kernel is also written in C. C provides a nice balance between high-level abstractions for productive software development and low-level control over the hardware, and thus it remains one of the primary languages chosen by computer systems programmers. In this section, we will briefly review some of the basic syntax and semantics of C.","title":"1. C Basics"},{"location":"ece2400-T01-intro-c-notes/#11-using-compiler-explorer-and-replit-to-experiment-with-c-programs","text":"Compiling a C program can be challenging, since it usually involves multiple command line tools and steps. So to get started, we will be using two online tools which will enable us to quickly experiment with small C programs. Later in the tutorial, we will see how to compile, build, test, debug, and evaluate both small and large C programs on the ecelinux machines. The first online tool is called Compiler Explorer, and it is accessed through the following link: https://godbolt.org . You can enter simple C functions in the left text box, and then Compiler Explorer will display the corresponding machine instructions (i.e., assembly code) in the right text box. This is a great way to quickly use your browser to see the connection between C programs and the low-level computer hardware. Compiler Explorer color codes the C program and the machine instructions, so it is possible to see which C statements compile into which machine instructions. There is a drop-down menu to choose different compilers. Choosing x86-64 gcc 7.2 roughly corresponds to the compiler we will be using on the ecelinux machines which is based on the Intel x86-64 instruction set. Choosing MIPS gcc 5.4 (el) roughly corresponds to the compiler used in ECE 2300 which is based on the MIPS instruction set. There is also a text box where you can enter various compiler command line options. The second online tool is called Repl.it, and it is accessed through the following link: http://repl.it . You can create a new \"repl\" by choosing the C programming language. You can enter simple C programs in the left text box. Clicking on the run button will first compile the C program into an executable binary, and then run this executable binary. This is a great way to quickly experiment with C programs in your browser. The output of running the program is shown in the right text box.","title":"1.1. Using Compiler Explorer and Repl.it to Experiment with C Programs"},{"location":"ece2400-T01-intro-c-notes/#c-functions","text":"The definition for a simple function to calculate the average of two integers is shown below. 1 2 3 4 5 int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } A C function definition specifies a named parameterized sequence of statements. C function definitions have four parts: a function name (e.g., avg on Line 1; a function parameter list (e.g., int x, int y on Line 1); a function return type (e.g., int at the beginning of Line 1); and the function body (e.g. Lines 2-5). In this tutorial, we will only use the int type for variables, but the C language supports a rich selection of different types for representing integer numbers, real numbers, characters, pointers, and composite structures. A function creates a new block and all variable declarations within the function are local to that scope. Line 3 is a variable initialization statement which first creates a new variable of type int named sum and then initializes this variable with the value of the expression x+y . Remember that all C statements end in a semicolon ( ; ). Line 4 is a return statement which causes the function to return the value of the corresponding expression (e.g., sum/2 ). Calling a C function involves setting the parameters in the parameter list, executing the sequence of statements in the function body, and then returning the return value. A C function call is just another kind of expression which evaluates to the function's return value. Enter the avg function into Compiler Explorer and take a look at the corresponding machine instructions for the Intel x86-64 instruction set. The avg function compiles to 15 machine instructions. In this course, you are not responsible for understanding these machine instructions, but it is still very important to recognize that C programs usually map relatively directly to machine instructions. Notice that the statement on Line 3 maps to four machine instructions (the C statement and the machine instructions are all colored yellow) including an add instruction. If you right click on one of the Intel x86-64 machine instructions and choose View Asm Doc , Compiler Explorer will display a detailed description of that machine instruction. Try finding out more about the add instruction. This instruction directly corresponds to the + operator in the avg function; this direct mapping from high-level syntax to low-level machine instructions is one of the key features of C. The + operator in a language such as Python or MATLAB would eventually correspond to hundreds of machine instructions! Enter -O3 into the Compiler options... text box and press return. This option tells the compiler to apply various optimizations to improve the performance of the compiled machine instructions. The avg function now compiles to six machine instructions, and we can see that Line 3 now maps to a single machine instruction (the C statement and the machine instruction are both are colored green). Even without understanding the details of these machine instructions, it should be obvious that reducing the number of machine instructions from 15 to six should improve performance. The definition for a simple main function to call the avg function and then print its result is shown below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include stdio.h int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( average of %d and %d is %d \\n , a , b , c , ); return 0 ; } Recall that the main function is special. The main function is always where program execution starts; in other words, the main function is always the first function to be called in any C program. Lines 11-13 are variable initialization statements. Line 13 calls the avg function with the values in variables a and b , and then the return value is used to initialize variable c . Line 14 calls the printf function to display text on the screen. The printf function is defined in the C standard library which is usually included along with every C compiler. More specifically, the printf function declaration is in a separate header file which is included on Line 1 using the C preprocessor. We will learn more about the C preprocessor later in this tutorial. The printf function always takes a format string as the first parameter, and then takes a variable number of parameters that are evaluated and substituted into the format string. The format string includes format specifiers (i.e., special codes) to indicate where to substitute these values. In this example, we are using the %d format specifier to indicate that we would like to substitute an integer into the format string. The format string can also include other special codes; for example, this format string includes a newline special code ( \\n ) which results in a line break. The return value of the main function is used as the exit status of the program; this is a way for a C program to tell the operating system whether or not the program ended successfully (by returning zero) or something went wrong (by returning a non-zero value). Enter the avg and main functions into Repl.it and then use the run button to compile and execute this C program. Try initializing a to 10 and b to 15. The average of these two integers is 12.5, but our program currently does not support arithmetic on non-integer values. In this case, the division operator (i.e., / ) truncates the result by always rounding towards zero. Quickly experimenting with small C programs can help illustrate subtle issues in C syntax and semantics. Question Write a simple function named avg3 to average three integers. Use Compiler Explorer to examine the corresponding machine instructions and identify how the + operators in the C program maps to add machine instructions. Use Repl.it to compile and execute a program with the avg3 function and a main function to call the average function and print its result. Experiment with averaging negative numbers, especially negative numbers where ideally the result would not be an integer (e.g., -7 , -5 , and -4 ). Problem 1.1: Writing an avg3 function Here is a programming question","title":"C Functions"},{"location":"ece2400-faq-c-basics/","text":"========================================================================== This is a collection of commonly asked questions on C basics. Q: How do understand the include guard? I noticed this on the sec2 handout 1 2 3 4 5 6 #ifndef WARM_COLORS_TXT #define WARM_COLORS_TXT red orange yellow #endif If I have already defined a macro, then excute the #ifndef directive, then include the content again. How does this operation skip over the contents of the same file? A: How do understand the include guard? From my understanding, what the #ifindef conditional does is check to see if this macro has been defined already. If it has not then, the code below the #ifindef line is run and the macro us defined. On the other hand, if it already exists, meaning it has a value, these lines below #ifindef will not be processed. So, the preprocessor determines if the macro exists before including the leading code in the compilation process. In other words, if something has a value during the course of the program, it is stored and so not changed again during the rest of the compilation process. An example I saw online that might help: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include stdio.h #define YEARS_OLD 12 #ifndef YEARS_OLD #define YEARS_OLD 10 #endif int main () { printf ( TechOnTheNet is over %d years old. \\n , YEARS_OLD ); return 0 ; } In this case, since YEARS_OLD is defined before ifndef, the code below it will be skipped over because the macro is already defined and so the compiler will skip over to #endif. If you run this code, you will see that YEARS_OLD has a value of 12. If we removed the first #define statement and just had this: 1 2 3 4 5 6 7 8 9 #ifndef YEARS_OLD #define YEARS_OLD 10 #endif int main () { printf ( TechOnTheNet is over %d years old. \\n , YEARS_OLD ); return 0 ; } Then the lines under #ifndef would be processed and YEARS_OLD would attain a value of 10. Hope this answers your question!","title":"FAQ on C Basics"},{"location":"ece2400-faq-c-basics/#q-how-do-understand-the-include-guard","text":"I noticed this on the sec2 handout 1 2 3 4 5 6 #ifndef WARM_COLORS_TXT #define WARM_COLORS_TXT red orange yellow #endif If I have already defined a macro, then excute the #ifndef directive, then include the content again. How does this operation skip over the contents of the same file?","title":"Q: How do understand the include guard?"},{"location":"ece2400-faq-c-basics/#a-how-do-understand-the-include-guard","text":"From my understanding, what the #ifindef conditional does is check to see if this macro has been defined already. If it has not then, the code below the #ifindef line is run and the macro us defined. On the other hand, if it already exists, meaning it has a value, these lines below #ifindef will not be processed. So, the preprocessor determines if the macro exists before including the leading code in the compilation process. In other words, if something has a value during the course of the program, it is stored and so not changed again during the rest of the compilation process. An example I saw online that might help: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include stdio.h #define YEARS_OLD 12 #ifndef YEARS_OLD #define YEARS_OLD 10 #endif int main () { printf ( TechOnTheNet is over %d years old. \\n , YEARS_OLD ); return 0 ; } In this case, since YEARS_OLD is defined before ifndef, the code below it will be skipped over because the macro is already defined and so the compiler will skip over to #endif. If you run this code, you will see that YEARS_OLD has a value of 12. If we removed the first #define statement and just had this: 1 2 3 4 5 6 7 8 9 #ifndef YEARS_OLD #define YEARS_OLD 10 #endif int main () { printf ( TechOnTheNet is over %d years old. \\n , YEARS_OLD ); return 0 ; } Then the lines under #ifndef would be processed and YEARS_OLD would attain a value of 10. Hope this answers your question!","title":"A: How do understand the include guard?"},{"location":"ece2400-pa1-math/","text":"Programming Assignment 1: Math Functions","title":"Ece2400 pa1 math"},{"location":"ece2400-pa1-math/#programming-assignment-1-math-functions","text":"","title":"Programming Assignment 1: Math Functions"},{"location":"ece2400-sec1-linux-git/","text":"Section 1: Linux and Git This section serves as gentle introduction to the basics of using Linux and Git on the ecelinux machines. The corresponding tutorial provides significantly more detail and background. 1. The ecelinux Machines We will be using the ecelinux workstations and servers for all of the programming assignments. The ecelinux machines all run the Red Hat Enterprise Linux 7 operating system, and they all use an identical setup. Linux is the operating system of choice for both cloud and IoT systems, so becoming familiar with Linux will pay dividends beyond just this course. Options For Using ecelinux machines directly use workstations in 314 Phillips Linux Lab log in remotely from 318 Phillips Windows Lab log in remotely from your own laptop in this discussion section, we will be directly logging into the workstations in the 314 Phillips ECE Linux Lab Logging Into a Workstatation use your NetID and your standard NetID password if you cannot log in, then it may be because you added the course since Thursday morning, we will be updating the access list often Joining The Zoom Screenshare for the discussion section, we will be using screensharing via zoom start zoom, choose from menubar: Applications Internet Zoom click \"Join a Meeting\" enter \"ece2400\" in the text box check \"Don't connect to Audio\" check \"Turn off my video\" click \"Join\" click \"View Options\" at the top choose \"Exit Full Screen\"_ drag window over to the right-hand edge to make it take up the right half of the screen 2. Repl.it Online Development Environment We will be using Repl.it to enable quickly exploring small C/C++ code snippets. Repl.it is a free online service which supports writing, compiling, and executing C/C++ programs completely online in your browser. start Firefox, choose from menubar: Applications Internet Firefox drag window over to the left-hand edge to make it take up the left half of the screen go to Repl.it here: https://repl.it you can use Repl.it without an account, you can reate an account later in the \"Search for a language\" drop-down choose Python the left panel is for entering code the right panel displays the results of executing that code enter the following Python program inspired by today's lecture 1 2 3 4 5 6 7 8 def min ( a , b ): if a b : c = a else : c = b return c print ( min ( 13 , 42 )) remember, indentation is important in Python! click \"run\" again go back to Repl.it here: https://repl.it in the \"Search for a language\" drop-down choose C you will see a default program replace that program with this new program inspired by today's lecture 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include stdio.h int min ( int a , int b ) { int c ; if ( a b ) c = a ; else c = b ; return c ; } int main () { printf ( %d , min ( 13 , 42 )); return 0 ; } click \"run\" by the end of next week you will understand this program students are encouraged to use Repl.it through the semester! 3. Linux Development Environment While Repl.it is great for experimenting with small code snippets, it is not suitable for serious system-level programming. So we will instead be using the ecelinux workstations and servers which run the Red Hat Enterprise Linux 7 operating system. The heart of the Linux operating system is the Linux command line. This is a text-based console where you can enter commands to interact with the operating system. Starting the Terminal the terminal is where you can work at the Linux command line choose from menubar: Applications Favorites Terminal drag window over to the left-hand edge to make it take up the left half of the screen Hello World We begin with the ubiquitous \"Hello, World\" example. To display the message \"Hello, World\" we will use the echo command. The echo command simply \"echoes\" its input to the console. 1 % echo Hello, World The string we provide to the echo command is called a command line argument . We use command line arguments to tell commands what they should operate on. Note that you do not need to enter % character. In a tutorial like this, the % simply indicates what you should type at the command line. To-Do On Your Own Experiment with using the echo command to display different messages. Manual Pages You can learn more about any Linux command by using the man command. Try using this to learn more about the echo command. 1 % man echo You can use the up/down keys to scroll the manual one line at a time, the space bar to scroll down one page at a time, and the q key to quit viewing the manual. Create, View, and List Files We can use the echo command and a feature called command output redirection to create simple text files. Command output redirection is discussed more in the full tutorial. Command output redirection uses the operator to take the output from one command and \"redirect\" it to a file. The following commands will create a new file named ece2400-tut1.txt that simply contains the text \"Computer Systems Programming\". 1 % echo Computer Systems Programming ece2400-tut1.txt We can use the cat command to quickly display the contents of a file. 1 % cat ece2400-tut1.txt For larger files, cat will output the entire file to the console so it may be hard to read the file as it streams past. We can use the less command to show one screen-full of text at a time. You can use the up/down keys to scroll the file one line at a time, the space bar to scroll down one page at a time, and the q key to quit viewing the file. 1 % less ece2400-tut1.txt You can use the ls command to list the filenames of the files you have created. 1 % ls We can provide command line options to the ls command to modify the command\u2019s behavior. For example, we can use the -1 (i.e., a dash followed by the number one) command line option to list one file per line, and we can we can use the -l (i.e., a dash followed by the letter l) command line option to provide a longer listing with more information about each file. To-Do On Your Own Create a new file named ece2400-tut1-layer3.txt which contains the third layer in the computing systems stack (i.e., programming language). Use cat and less to verify the file contents. Create, Change, and List Directories Obviously, having all files in a single location would be hard to manage effectively. We can use directories (also called folders) to logically organize our files, just like one can use physical folders to organize physical pieces of paper. The mechanism for organizing files and directories is called the file system. When you first login to an ecelinux machine, you will be in your home directory. This is your own private space on the server that you can use to work on the programming assignments and store your files. You can use the pwd command to print the directory in which you are currently working, which is known as the current working directory. 1 2 % pwd /home/ netid You should see output similar to what is shown above, but instead of netid it should show your actual NetID. The pwd command shows a directory path. A directory path is a list of nested directory names; it describes a \"path\" to get to a specific file or directory. So the above path indicates that there is a toplevel directory named home that contains a directory named netid . This is the directory path to your home directory. As an aside, notice that Linux uses a forward slash ( / ) to separate directories, while Windows uses a back slash ( \\ ) for the same purpose. We can use the mkdir command to make new directories. The following command will make a new directory named ece2400 within your home directory. 1 % mkdir ece2400 We can use the cd command to change our current working directory. The following command will change the current working directory to be the newly created ece2400 directory, before displaying the current working directory with the pwd command. 1 2 3 % cd ece2400 % pwd /home/ netid /ece2400 Use the mkdir , cd , and pwd commands to make another directory. 1 2 3 4 % mkdir tut1 % cd tut1 % pwd /home/ netid /ece2400/tut1 We sometimes say that tut1 is a subdirectory or a child directory of the ece2400 directory. We might also say that the ece2400 directory is the parent directory of the tut1 directory. Use the following command to create a new file in this child directory. 1 2 3 4 % cd /home/ netid /ece2400/tut1 % echo Computer Systems Programming ece2400-tut1.txt % mkdir dirA % ls You can use the tree command to visualize the directory layout and where files are located: 1 2 % cd ~/ece2400 % tree Note that the tilde character ( ~ ) is a shortcut which always refers to your home directory. There are a few other very useful shortcuts. You can use a single dot ( . ) to refer to the current working directory, and you can use a double dot ( .. ) to refer to the parent directory of the current working directory. 1 2 3 4 % cd ~/ece2400/tut1 % cd .. % cd .. % pwd To-Do On Your Own Experiment with creating additional directories and files within the ece2400/tut1 subdirectory. Try using the tree command to display your newly created directory hierarchy. Copy, Move, and Remove Files and Directories We can use the cp command to copy files. The first argument is the name of the file you want to copy, and the second argument is the new name to give to the copy. The following commands will make two copies of the files we created in the previous section. 1 2 3 4 % cd ~/ece2400/tut1 % cp ece2400-tut1.txt ece2400-tut1-a.txt % cp ece2400-tut1.txt ece2400-tut1-b.txt % ls Instead of copying we can also move a file with the mv command: 1 2 3 % cd ~/ece2400/tut1 % mv ece2400-tut1.txt ece2400-tut1-c.txt % ls Finally, we can use the rm command to remove files. 1 2 3 % cd ~/ece2400/tut1 % ls % rm ece2400-tut1-a.txt To-Do On Your Own Creating additional directories and files within the ece2400/tut1 subdirectory, and then use the cp , mv , and rm commands to copy, move, and remove the newly created directories and files. Use the ls and tree commands to display your file and directory organization. Course Setup Script Once you are logged into an ecelinux machine, you will need to setup the working environment with the following command in order to work on the course programming assignments. 1 % source setup-ece2400.sh Editors Students are free to use any text editor they want. We recommend geany . You can start geany like this: 1 % geany Try opening and editing the ece2400-tut1.txt file you created earlier. 4. Git Distributed Version Control System In this course, we will be using Git as our revision control and source code management system. We will be using GitHub for centralized online repository hosting, and TravisCI for online continuous integration testing. These tools will enable us to adopt an agile hardware development methodology so your group can rapidly collaborate and iterate on the design, verification, and evaluation of the assignments. You can check to see if you have a GitHub account on github.com using this link: https://github.com/githubid where githubid is your GitHub username on github.com . If the above link does not work, then you do not have an GitHub account on github.com . You will need to create one here: https://github.com/join Your NetID makes a great GitHub username on github.com. Be sure to use your Cornell University email address. Once your account is setup, please make sure you set your full name so we can know who you are on GitHub.","title":"Section 1: Linux and Git"},{"location":"ece2400-sec1-linux-git/#section-1-linux-and-git","text":"This section serves as gentle introduction to the basics of using Linux and Git on the ecelinux machines. The corresponding tutorial provides significantly more detail and background.","title":"Section 1: Linux and Git"},{"location":"ece2400-sec1-linux-git/#1-the-ecelinux-machines","text":"We will be using the ecelinux workstations and servers for all of the programming assignments. The ecelinux machines all run the Red Hat Enterprise Linux 7 operating system, and they all use an identical setup. Linux is the operating system of choice for both cloud and IoT systems, so becoming familiar with Linux will pay dividends beyond just this course.","title":"1. The ecelinux Machines"},{"location":"ece2400-sec1-linux-git/#options-for-using-ecelinux-machines","text":"directly use workstations in 314 Phillips Linux Lab log in remotely from 318 Phillips Windows Lab log in remotely from your own laptop in this discussion section, we will be directly logging into the workstations in the 314 Phillips ECE Linux Lab","title":"Options For Using ecelinux machines"},{"location":"ece2400-sec1-linux-git/#logging-into-a-workstatation","text":"use your NetID and your standard NetID password if you cannot log in, then it may be because you added the course since Thursday morning, we will be updating the access list often","title":"Logging Into a Workstatation"},{"location":"ece2400-sec1-linux-git/#joining-the-zoom-screenshare","text":"for the discussion section, we will be using screensharing via zoom start zoom, choose from menubar: Applications Internet Zoom click \"Join a Meeting\" enter \"ece2400\" in the text box check \"Don't connect to Audio\" check \"Turn off my video\" click \"Join\" click \"View Options\" at the top choose \"Exit Full Screen\"_ drag window over to the right-hand edge to make it take up the right half of the screen","title":"Joining The Zoom Screenshare"},{"location":"ece2400-sec1-linux-git/#2-replit-online-development-environment","text":"We will be using Repl.it to enable quickly exploring small C/C++ code snippets. Repl.it is a free online service which supports writing, compiling, and executing C/C++ programs completely online in your browser. start Firefox, choose from menubar: Applications Internet Firefox drag window over to the left-hand edge to make it take up the left half of the screen go to Repl.it here: https://repl.it you can use Repl.it without an account, you can reate an account later in the \"Search for a language\" drop-down choose Python the left panel is for entering code the right panel displays the results of executing that code enter the following Python program inspired by today's lecture 1 2 3 4 5 6 7 8 def min ( a , b ): if a b : c = a else : c = b return c print ( min ( 13 , 42 )) remember, indentation is important in Python! click \"run\" again go back to Repl.it here: https://repl.it in the \"Search for a language\" drop-down choose C you will see a default program replace that program with this new program inspired by today's lecture 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include stdio.h int min ( int a , int b ) { int c ; if ( a b ) c = a ; else c = b ; return c ; } int main () { printf ( %d , min ( 13 , 42 )); return 0 ; } click \"run\" by the end of next week you will understand this program students are encouraged to use Repl.it through the semester!","title":"2. Repl.it Online Development Environment"},{"location":"ece2400-sec1-linux-git/#3-linux-development-environment","text":"While Repl.it is great for experimenting with small code snippets, it is not suitable for serious system-level programming. So we will instead be using the ecelinux workstations and servers which run the Red Hat Enterprise Linux 7 operating system. The heart of the Linux operating system is the Linux command line. This is a text-based console where you can enter commands to interact with the operating system.","title":"3. Linux Development Environment"},{"location":"ece2400-sec1-linux-git/#starting-the-terminal","text":"the terminal is where you can work at the Linux command line choose from menubar: Applications Favorites Terminal drag window over to the left-hand edge to make it take up the left half of the screen","title":"Starting the Terminal"},{"location":"ece2400-sec1-linux-git/#hello-world","text":"We begin with the ubiquitous \"Hello, World\" example. To display the message \"Hello, World\" we will use the echo command. The echo command simply \"echoes\" its input to the console. 1 % echo Hello, World The string we provide to the echo command is called a command line argument . We use command line arguments to tell commands what they should operate on. Note that you do not need to enter % character. In a tutorial like this, the % simply indicates what you should type at the command line. To-Do On Your Own Experiment with using the echo command to display different messages.","title":"Hello World"},{"location":"ece2400-sec1-linux-git/#manual-pages","text":"You can learn more about any Linux command by using the man command. Try using this to learn more about the echo command. 1 % man echo You can use the up/down keys to scroll the manual one line at a time, the space bar to scroll down one page at a time, and the q key to quit viewing the manual.","title":"Manual Pages"},{"location":"ece2400-sec1-linux-git/#create-view-and-list-files","text":"We can use the echo command and a feature called command output redirection to create simple text files. Command output redirection is discussed more in the full tutorial. Command output redirection uses the operator to take the output from one command and \"redirect\" it to a file. The following commands will create a new file named ece2400-tut1.txt that simply contains the text \"Computer Systems Programming\". 1 % echo Computer Systems Programming ece2400-tut1.txt We can use the cat command to quickly display the contents of a file. 1 % cat ece2400-tut1.txt For larger files, cat will output the entire file to the console so it may be hard to read the file as it streams past. We can use the less command to show one screen-full of text at a time. You can use the up/down keys to scroll the file one line at a time, the space bar to scroll down one page at a time, and the q key to quit viewing the file. 1 % less ece2400-tut1.txt You can use the ls command to list the filenames of the files you have created. 1 % ls We can provide command line options to the ls command to modify the command\u2019s behavior. For example, we can use the -1 (i.e., a dash followed by the number one) command line option to list one file per line, and we can we can use the -l (i.e., a dash followed by the letter l) command line option to provide a longer listing with more information about each file. To-Do On Your Own Create a new file named ece2400-tut1-layer3.txt which contains the third layer in the computing systems stack (i.e., programming language). Use cat and less to verify the file contents.","title":"Create, View, and List Files"},{"location":"ece2400-sec1-linux-git/#create-change-and-list-directories","text":"Obviously, having all files in a single location would be hard to manage effectively. We can use directories (also called folders) to logically organize our files, just like one can use physical folders to organize physical pieces of paper. The mechanism for organizing files and directories is called the file system. When you first login to an ecelinux machine, you will be in your home directory. This is your own private space on the server that you can use to work on the programming assignments and store your files. You can use the pwd command to print the directory in which you are currently working, which is known as the current working directory. 1 2 % pwd /home/ netid You should see output similar to what is shown above, but instead of netid it should show your actual NetID. The pwd command shows a directory path. A directory path is a list of nested directory names; it describes a \"path\" to get to a specific file or directory. So the above path indicates that there is a toplevel directory named home that contains a directory named netid . This is the directory path to your home directory. As an aside, notice that Linux uses a forward slash ( / ) to separate directories, while Windows uses a back slash ( \\ ) for the same purpose. We can use the mkdir command to make new directories. The following command will make a new directory named ece2400 within your home directory. 1 % mkdir ece2400 We can use the cd command to change our current working directory. The following command will change the current working directory to be the newly created ece2400 directory, before displaying the current working directory with the pwd command. 1 2 3 % cd ece2400 % pwd /home/ netid /ece2400 Use the mkdir , cd , and pwd commands to make another directory. 1 2 3 4 % mkdir tut1 % cd tut1 % pwd /home/ netid /ece2400/tut1 We sometimes say that tut1 is a subdirectory or a child directory of the ece2400 directory. We might also say that the ece2400 directory is the parent directory of the tut1 directory. Use the following command to create a new file in this child directory. 1 2 3 4 % cd /home/ netid /ece2400/tut1 % echo Computer Systems Programming ece2400-tut1.txt % mkdir dirA % ls You can use the tree command to visualize the directory layout and where files are located: 1 2 % cd ~/ece2400 % tree Note that the tilde character ( ~ ) is a shortcut which always refers to your home directory. There are a few other very useful shortcuts. You can use a single dot ( . ) to refer to the current working directory, and you can use a double dot ( .. ) to refer to the parent directory of the current working directory. 1 2 3 4 % cd ~/ece2400/tut1 % cd .. % cd .. % pwd To-Do On Your Own Experiment with creating additional directories and files within the ece2400/tut1 subdirectory. Try using the tree command to display your newly created directory hierarchy.","title":"Create, Change, and List Directories"},{"location":"ece2400-sec1-linux-git/#copy-move-and-remove-files-and-directories","text":"We can use the cp command to copy files. The first argument is the name of the file you want to copy, and the second argument is the new name to give to the copy. The following commands will make two copies of the files we created in the previous section. 1 2 3 4 % cd ~/ece2400/tut1 % cp ece2400-tut1.txt ece2400-tut1-a.txt % cp ece2400-tut1.txt ece2400-tut1-b.txt % ls Instead of copying we can also move a file with the mv command: 1 2 3 % cd ~/ece2400/tut1 % mv ece2400-tut1.txt ece2400-tut1-c.txt % ls Finally, we can use the rm command to remove files. 1 2 3 % cd ~/ece2400/tut1 % ls % rm ece2400-tut1-a.txt To-Do On Your Own Creating additional directories and files within the ece2400/tut1 subdirectory, and then use the cp , mv , and rm commands to copy, move, and remove the newly created directories and files. Use the ls and tree commands to display your file and directory organization.","title":"Copy, Move, and Remove Files and Directories"},{"location":"ece2400-sec1-linux-git/#course-setup-script","text":"Once you are logged into an ecelinux machine, you will need to setup the working environment with the following command in order to work on the course programming assignments. 1 % source setup-ece2400.sh","title":"Course Setup Script"},{"location":"ece2400-sec1-linux-git/#editors","text":"Students are free to use any text editor they want. We recommend geany . You can start geany like this: 1 % geany Try opening and editing the ece2400-tut1.txt file you created earlier.","title":"Editors"},{"location":"ece2400-sec1-linux-git/#4-git-distributed-version-control-system","text":"In this course, we will be using Git as our revision control and source code management system. We will be using GitHub for centralized online repository hosting, and TravisCI for online continuous integration testing. These tools will enable us to adopt an agile hardware development methodology so your group can rapidly collaborate and iterate on the design, verification, and evaluation of the assignments. You can check to see if you have a GitHub account on github.com using this link: https://github.com/githubid where githubid is your GitHub username on github.com . If the above link does not work, then you do not have an GitHub account on github.com . You will need to create one here: https://github.com/join Your NetID makes a great GitHub username on github.com. Be sure to use your Cornell University email address. Once your account is setup, please make sure you set your full name so we can know who you are on GitHub.","title":"4. Git Distributed Version Control System"},{"location":"ece2400-sec2-c-basics/","text":"Section 2: Compiling and Running C Programs This section serves as gentle introduction to the basics of compiling and running C programs on the ecelinux machines. The corresponding tutorial provides significantly more detail and background. 1. The ecelinux Machines Follow the same process as in the last section. login to a workstation with your NetID and password for the discussion section, we will be using screensharing via zoom start zoom, choose from menubar: Applications Internet Zoom click \"Join a Meeting\" enter \"ece2400\" in the text box check \"Don't connect to Audio\" check \"Turn off my video\" click \"Join\" click \"View Options\" at the top choose \"Exit Full Screen\"_ drag window over to the right-hand edge to make it take up the right half of the screen 2. Basic Git Usage In this course, we will be using Git as our revision control and source code management system. We will be using GitHub for centralized online repository hosting, and TravisCI for online continuous integration testing. These tools will enable us to adopt an agile hardware development methodology so your group can rapidly collaborate and iterate on the design, verification, and evaluation of the assignments. You should have already setup your GitHub account on github.com during the previous section. Please also make sure you have setup your ssh keys correctly (see Section 2 of the ECE 2400 Tutorial 2). Fork'ing a repo means making a copy of that repo for your own local use. We won't actually be forking repos for the programming assignments, but it is an easy way for you to grab some example code for the discussion section. Go to the example repo here: https://github.com/cornell-ece2400/ece2400-sec2 Click on the \"Fork\" button. Wait a few seconds and then visit the new copy of this repo in your own person GitHub workspace: https://github.com/ githubid /ece2400-sec2 Where githubid is your GitHubID. Now let's clone your new repo to the ecelinux machine. 1 2 3 4 5 % source setup-ece2400.sh % cd ${ HOME } /ece2400 % git clone git@github.com: githubid /ece2400-sec2 sec2 % cd sec2 % cat README.md Where githubid is your GitHubID. Now let's add some new files to the repository. Use your favorite text editor (e.g., Geany) to create a file named warm-colors.txt with three warm colors: 1 2 3 red orange yellow Now use your favorite text editor again to create a file named cool-colors.txt with three cool colors. 1 2 3 blue green purple Now let's add these files to our repository. First use the git status command to check on the status of the repository. 1 2 % cd ${ HOME } /ece2400/sec2 % git status You should see that git has noticed two \"untracked files\" which are in the working directory but are not currently being tracked by git. Let's \"add\" these two files to git's \"staging\" area so it now knows it should keep track of them: 1 2 3 4 % cd ${ HOME } /ece2400/sec2 % git add warm-colors.txt % git add cool-colors.txt % git status The status of these two files have changed. Git reports that both of the new files are ready to be committed. Let's go ahead and commit these changes into your local repository. 1 2 % cd ${ HOME } /ece2400/sec2 % git commit -m add some colors Note that nothing has happened on GitHub yet. GitHub does not know anything about these local changes. We need to explicitly \"push\" our new commits up to GitHub like this: 1 2 % cd ${ HOME } /ece2400/sec2 % git push Now go to the repository page on GitHub and verify that there are two new files. Let's try making a change to this repository through the GitHub web interface. Click on \"Create new file\". Name the file languages.txt and add a list of programming languages: 1 2 3 4 5 C C++ Python MATLAB Java Now click \"Commit new file\". Verify that there is a new file in the repo using the GitHub web interface. Now let's \"pull\" these new changes from GitHub to your local repo on ecelinux : 1 2 3 % cd ${ HOME } /ece2400/sec2 % git pull % cat languages.txt 3. C Preprocessor Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocesor is not really part of the C programming language. The C preprocessor simply manipulates the text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we wish to create a text file which includes both warm and cool colors. We could simply copy-and-paste our lists from warm-colors.txt and cool-colors.txt , but this would be redundant and difficult to maintain if we wanted to add a new warm or cool color. We can instead use the C preprocessor to include the contents of one text file in another text file. Use your favorite text editor to create a new file named colors-in.txt with the following content: 1 2 #include warm-colors.txt #include cool-colors.txt The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. The #include directive specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). Now we can use the C preprocessor ( cpp ) to preprocess the -in.txt files into a final text file that contains both the warm and cool colors. 1 2 3 % cd ${ HOME } /ece2400/sec2 % cpp -o colors.txt colors-in.txt % cat colors.txt The -o command line option is used to specify the name of the output file. The content of the colors.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1 colors-in.txt # 1 built-in # 1 command-line # 31 command-line # 1 /usr/include/stdc-predef.h 1 3 4 # 32 command-line 2 # 1 colors-in.txt # 1 warm-colors.txt 1 red orange yellow # 2 colors-in.txt 2 # 1 cool-colors.txt 1 blue green purple # 2 colors-in.txt 2 The C preprocessor has included all of the colors in a single output file, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. We can tell cpp to not include this extra metadata with the -P command line option. 1 2 3 % cd ${ HOME } /ece2400/sec2 % cpp -P -o colors.txt colors-in.txt % cat colors.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor in the previous section when we included the stdio.h header file which includes the declaration of the printf function. We will also use the C preprocessor to create include guards . An include guard is a way to ensure that the contents of a given file is only inserted into the output file once, even if we include it multiple times. For example, modify warm-colors.txt as follows: 1 2 3 4 5 6 #ifndef WARM_COLORS_TXT #define WARM_COLORS_TXT red orange yellow #endif The #ifndef directive is a conditional which will only include the content after the directive if the given preprocessor macro is defined. The #define directive \"defines\" the given preprocessor macro. So these directives essentially check to see if WARM_COLORS_TXT is defined and if not it will include the text in the file ... and also define WARM_COLORS_TXT . If we try and include this same file again then WARM_COLORS_TXT will already be defined and we will skip over the contents of the file. Modify cool-colors.txt as follows: 1 2 3 4 5 6 #ifndef COOL_COLORS_TXT #define COOL_COLORS_TXT blue green purple #endif And now modify colors-in.txt to include each file three times: 1 2 3 4 5 6 #include warm-colors.txt #include warm-colors.txt #include warm-colors.txt #include cool-colors.txt #include cool-colors.txt #include cool-colors.txt If you run the C preprocessor you will see that the colors are only included once because of the include guards. 1 2 3 % cd ${ HOME } /ece2400/sec2 % cpp -P -o colors.txt colors-in.txt % cat colors.txt 4. Compiling and Running a Single-File C Program Now that we have explored how to use the C preprocessor for file inclusion and include guards, we will can turn out attention to writing C programs. We will begin by writing a single-file C program to calculate the average of two integers. Our goal is to reproduce what we did earlier by using various command line tools on the ecelinux machines instead of using Compiler Explorer and Repl.it. Edit the avg-sfile.c code to include an appropriate implementation of the avg function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include stdio.h int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( average of %d and %d is %d \\n , a , b , c ); return 0 ; } We use a compiler to compiler the C source code into an executable binary (i.e., the actual bits) that the machine can understand. In this course we will be using the GNU C compiler ( gcc ). Let's go ahead and give this a try: 1 2 3 4 % cd ${ HOME } /ece2400/sec2 % gcc -o avg-sfile avg-sfile.c % objdump -dC avg-sfile | less % ./avg-sfile The objdump command takes an executable binary and shows you the machine instructions in a human readable format. We are piping it through less so we can scroll through the output. Try and find the machine instructions that go along with the avg function. Then we actually execute the binary by simply calling it as any other Linux command. Recall that a single dot ( . ) always refers to the current working directory. Essentially we are telling Linux that we want to run the executable named avg-sfile which is located in the current working directory. 5. Compiling and Running a Multi-File C Program Real C programs are almost never contained in a single file. They require many files which must be individually compiled and then linked together. To illustrate this process we will break our avg-sfile.c source file into two files: avg.c will contain the avg function, and avg-mfile.c will contain the main function. Go ahead and use your favorite text editor to create the avg.c file: 1 2 3 4 5 6 7 #include avg.h int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } And now create the avg-mfile.c file: 1 2 3 4 5 6 7 8 9 10 11 #include stdio.h #include avg.h int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( average of %d and %d is %d \\n , a , b , c ); return 0 ; } We will use gcc compile the avg.c source file into the avg.o object file, and we will also use gcc to compile the avg-mfile.c source file into the avg-mfile.o object file. Finally, we can use gcc to link both object files along with the pre-compiled C standard library and any startup code to produce an executable binary. We will also need a header file named avg.h . Header files are the key to multi-file C programs. The avg-mfile.c source file needs to call the avg function, but the avg function is in a different source file. When we compile the avg-mfile.c source file, how will the compiler know that the avg function exists to ensure the programmer is not accidentally calling an undefined function? How will the compiler know what parameters the avg function takes, so it can perform type checking? The avg-mfile.c source file cannot directly include avg.c since that would result in the same function being compiled twice into two different object files (which would cause a linker error). What we need to do is have a way to tell avg-mfile.c the avg function prototype (i.e., the interface of the function including its name, parameter list, and return type) but not the avg function implementation . We do this with a function declaration . A function definition specifies both the function prototype (interface) and the implementation at the same time, while a function declaration just specifies the function prototype without the implementation. A header file contains all of the function declarations but no function definitions. All of the function definitions are placed in a source file that goes along with the header file. If we want to call a function that is defined in a different source file, then we simply use the #include directive to include the appropriate header file. The linker will take care of making sure the machine instructions corresponding to every function definition is linked together into the executable binary. Create a header file for avg.c named avg.h with the following contents. 1 2 3 4 5 6 #ifndef TUT3_C_AVG_H #define TUT3_C_AVG_H int avg ( int x , int y ); #endif Notice the include guards implemented using the C preprocessor. Let's go ahead and compile avg.c and avg-mfile.c into their corresponding object files: 1 2 3 % cd ${ HOME } /ece2400/sec2 % gcc -c -o avg.o avg.c % gcc -c -o avg-mfile.o avg-mfile.c And now we can link these two object files together to create an executable binary that we can run: 1 2 3 % cd ${ HOME } /ece2400/sec2 % gcc -o avg-mfile avg.o avg-mfile.o % ./avg-mfile We can actually simplify this process and do the compilation and linking in a single step like this: 1 2 3 % cd ${ HOME } /ece2400/sec2 % gcc -o avg-mfile avg.c avg-mfile.c % ./avg-mfile","title":"Section 2: Compiling and Running C Programs"},{"location":"ece2400-sec2-c-basics/#section-2-compiling-and-running-c-programs","text":"This section serves as gentle introduction to the basics of compiling and running C programs on the ecelinux machines. The corresponding tutorial provides significantly more detail and background.","title":"Section 2: Compiling and Running C Programs"},{"location":"ece2400-sec2-c-basics/#1-the-ecelinux-machines","text":"Follow the same process as in the last section. login to a workstation with your NetID and password for the discussion section, we will be using screensharing via zoom start zoom, choose from menubar: Applications Internet Zoom click \"Join a Meeting\" enter \"ece2400\" in the text box check \"Don't connect to Audio\" check \"Turn off my video\" click \"Join\" click \"View Options\" at the top choose \"Exit Full Screen\"_ drag window over to the right-hand edge to make it take up the right half of the screen","title":"1. The ecelinux Machines"},{"location":"ece2400-sec2-c-basics/#2-basic-git-usage","text":"In this course, we will be using Git as our revision control and source code management system. We will be using GitHub for centralized online repository hosting, and TravisCI for online continuous integration testing. These tools will enable us to adopt an agile hardware development methodology so your group can rapidly collaborate and iterate on the design, verification, and evaluation of the assignments. You should have already setup your GitHub account on github.com during the previous section. Please also make sure you have setup your ssh keys correctly (see Section 2 of the ECE 2400 Tutorial 2). Fork'ing a repo means making a copy of that repo for your own local use. We won't actually be forking repos for the programming assignments, but it is an easy way for you to grab some example code for the discussion section. Go to the example repo here: https://github.com/cornell-ece2400/ece2400-sec2 Click on the \"Fork\" button. Wait a few seconds and then visit the new copy of this repo in your own person GitHub workspace: https://github.com/ githubid /ece2400-sec2 Where githubid is your GitHubID. Now let's clone your new repo to the ecelinux machine. 1 2 3 4 5 % source setup-ece2400.sh % cd ${ HOME } /ece2400 % git clone git@github.com: githubid /ece2400-sec2 sec2 % cd sec2 % cat README.md Where githubid is your GitHubID. Now let's add some new files to the repository. Use your favorite text editor (e.g., Geany) to create a file named warm-colors.txt with three warm colors: 1 2 3 red orange yellow Now use your favorite text editor again to create a file named cool-colors.txt with three cool colors. 1 2 3 blue green purple Now let's add these files to our repository. First use the git status command to check on the status of the repository. 1 2 % cd ${ HOME } /ece2400/sec2 % git status You should see that git has noticed two \"untracked files\" which are in the working directory but are not currently being tracked by git. Let's \"add\" these two files to git's \"staging\" area so it now knows it should keep track of them: 1 2 3 4 % cd ${ HOME } /ece2400/sec2 % git add warm-colors.txt % git add cool-colors.txt % git status The status of these two files have changed. Git reports that both of the new files are ready to be committed. Let's go ahead and commit these changes into your local repository. 1 2 % cd ${ HOME } /ece2400/sec2 % git commit -m add some colors Note that nothing has happened on GitHub yet. GitHub does not know anything about these local changes. We need to explicitly \"push\" our new commits up to GitHub like this: 1 2 % cd ${ HOME } /ece2400/sec2 % git push Now go to the repository page on GitHub and verify that there are two new files. Let's try making a change to this repository through the GitHub web interface. Click on \"Create new file\". Name the file languages.txt and add a list of programming languages: 1 2 3 4 5 C C++ Python MATLAB Java Now click \"Commit new file\". Verify that there is a new file in the repo using the GitHub web interface. Now let's \"pull\" these new changes from GitHub to your local repo on ecelinux : 1 2 3 % cd ${ HOME } /ece2400/sec2 % git pull % cat languages.txt","title":"2. Basic Git Usage"},{"location":"ece2400-sec2-c-basics/#3-c-preprocessor","text":"Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocesor is not really part of the C programming language. The C preprocessor simply manipulates the text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we wish to create a text file which includes both warm and cool colors. We could simply copy-and-paste our lists from warm-colors.txt and cool-colors.txt , but this would be redundant and difficult to maintain if we wanted to add a new warm or cool color. We can instead use the C preprocessor to include the contents of one text file in another text file. Use your favorite text editor to create a new file named colors-in.txt with the following content: 1 2 #include warm-colors.txt #include cool-colors.txt The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. The #include directive specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). Now we can use the C preprocessor ( cpp ) to preprocess the -in.txt files into a final text file that contains both the warm and cool colors. 1 2 3 % cd ${ HOME } /ece2400/sec2 % cpp -o colors.txt colors-in.txt % cat colors.txt The -o command line option is used to specify the name of the output file. The content of the colors.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1 colors-in.txt # 1 built-in # 1 command-line # 31 command-line # 1 /usr/include/stdc-predef.h 1 3 4 # 32 command-line 2 # 1 colors-in.txt # 1 warm-colors.txt 1 red orange yellow # 2 colors-in.txt 2 # 1 cool-colors.txt 1 blue green purple # 2 colors-in.txt 2 The C preprocessor has included all of the colors in a single output file, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. We can tell cpp to not include this extra metadata with the -P command line option. 1 2 3 % cd ${ HOME } /ece2400/sec2 % cpp -P -o colors.txt colors-in.txt % cat colors.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor in the previous section when we included the stdio.h header file which includes the declaration of the printf function. We will also use the C preprocessor to create include guards . An include guard is a way to ensure that the contents of a given file is only inserted into the output file once, even if we include it multiple times. For example, modify warm-colors.txt as follows: 1 2 3 4 5 6 #ifndef WARM_COLORS_TXT #define WARM_COLORS_TXT red orange yellow #endif The #ifndef directive is a conditional which will only include the content after the directive if the given preprocessor macro is defined. The #define directive \"defines\" the given preprocessor macro. So these directives essentially check to see if WARM_COLORS_TXT is defined and if not it will include the text in the file ... and also define WARM_COLORS_TXT . If we try and include this same file again then WARM_COLORS_TXT will already be defined and we will skip over the contents of the file. Modify cool-colors.txt as follows: 1 2 3 4 5 6 #ifndef COOL_COLORS_TXT #define COOL_COLORS_TXT blue green purple #endif And now modify colors-in.txt to include each file three times: 1 2 3 4 5 6 #include warm-colors.txt #include warm-colors.txt #include warm-colors.txt #include cool-colors.txt #include cool-colors.txt #include cool-colors.txt If you run the C preprocessor you will see that the colors are only included once because of the include guards. 1 2 3 % cd ${ HOME } /ece2400/sec2 % cpp -P -o colors.txt colors-in.txt % cat colors.txt","title":"3. C Preprocessor"},{"location":"ece2400-sec2-c-basics/#4-compiling-and-running-a-single-file-c-program","text":"Now that we have explored how to use the C preprocessor for file inclusion and include guards, we will can turn out attention to writing C programs. We will begin by writing a single-file C program to calculate the average of two integers. Our goal is to reproduce what we did earlier by using various command line tools on the ecelinux machines instead of using Compiler Explorer and Repl.it. Edit the avg-sfile.c code to include an appropriate implementation of the avg function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include stdio.h int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( average of %d and %d is %d \\n , a , b , c ); return 0 ; } We use a compiler to compiler the C source code into an executable binary (i.e., the actual bits) that the machine can understand. In this course we will be using the GNU C compiler ( gcc ). Let's go ahead and give this a try: 1 2 3 4 % cd ${ HOME } /ece2400/sec2 % gcc -o avg-sfile avg-sfile.c % objdump -dC avg-sfile | less % ./avg-sfile The objdump command takes an executable binary and shows you the machine instructions in a human readable format. We are piping it through less so we can scroll through the output. Try and find the machine instructions that go along with the avg function. Then we actually execute the binary by simply calling it as any other Linux command. Recall that a single dot ( . ) always refers to the current working directory. Essentially we are telling Linux that we want to run the executable named avg-sfile which is located in the current working directory.","title":"4. Compiling and Running a Single-File C Program"},{"location":"ece2400-sec2-c-basics/#5-compiling-and-running-a-multi-file-c-program","text":"Real C programs are almost never contained in a single file. They require many files which must be individually compiled and then linked together. To illustrate this process we will break our avg-sfile.c source file into two files: avg.c will contain the avg function, and avg-mfile.c will contain the main function. Go ahead and use your favorite text editor to create the avg.c file: 1 2 3 4 5 6 7 #include avg.h int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } And now create the avg-mfile.c file: 1 2 3 4 5 6 7 8 9 10 11 #include stdio.h #include avg.h int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( average of %d and %d is %d \\n , a , b , c ); return 0 ; } We will use gcc compile the avg.c source file into the avg.o object file, and we will also use gcc to compile the avg-mfile.c source file into the avg-mfile.o object file. Finally, we can use gcc to link both object files along with the pre-compiled C standard library and any startup code to produce an executable binary. We will also need a header file named avg.h . Header files are the key to multi-file C programs. The avg-mfile.c source file needs to call the avg function, but the avg function is in a different source file. When we compile the avg-mfile.c source file, how will the compiler know that the avg function exists to ensure the programmer is not accidentally calling an undefined function? How will the compiler know what parameters the avg function takes, so it can perform type checking? The avg-mfile.c source file cannot directly include avg.c since that would result in the same function being compiled twice into two different object files (which would cause a linker error). What we need to do is have a way to tell avg-mfile.c the avg function prototype (i.e., the interface of the function including its name, parameter list, and return type) but not the avg function implementation . We do this with a function declaration . A function definition specifies both the function prototype (interface) and the implementation at the same time, while a function declaration just specifies the function prototype without the implementation. A header file contains all of the function declarations but no function definitions. All of the function definitions are placed in a source file that goes along with the header file. If we want to call a function that is defined in a different source file, then we simply use the #include directive to include the appropriate header file. The linker will take care of making sure the machine instructions corresponding to every function definition is linked together into the executable binary. Create a header file for avg.c named avg.h with the following contents. 1 2 3 4 5 6 #ifndef TUT3_C_AVG_H #define TUT3_C_AVG_H int avg ( int x , int y ); #endif Notice the include guards implemented using the C preprocessor. Let's go ahead and compile avg.c and avg-mfile.c into their corresponding object files: 1 2 3 % cd ${ HOME } /ece2400/sec2 % gcc -c -o avg.o avg.c % gcc -c -o avg-mfile.o avg-mfile.c And now we can link these two object files together to create an executable binary that we can run: 1 2 3 % cd ${ HOME } /ece2400/sec2 % gcc -o avg-mfile avg.o avg-mfile.o % ./avg-mfile We can actually simplify this process and do the compilation and linking in a single step like this: 1 2 3 % cd ${ HOME } /ece2400/sec2 % gcc -o avg-mfile avg.c avg-mfile.c % ./avg-mfile","title":"5. Compiling and Running a Multi-File C Program"},{"location":"ece2400-sec3-c-build-test/","text":"Section 3: C Build and Test Frameworks In the previous discussion section, you learned how to explicitly compile and run C programs from the command line. You learned how to use the GNU C Compiler ( gcc ) to compile both a single-file and multi-file program that calculated the average of two integers. You probably noticed that it can be tedious to have to carefully enter the correct commands on the command line. We also need to carefully track which steps need to be redone whenever we change a C source file. In this discussion section, we will explore using a build framework based on CMake to automate this process. In the previous discussion section, you also learned how to do ad-hoc testing by executing a function and then simply printing out the result to the terminal. In this discussion section, we will explore using a test framework to automate this process. Using a build and test framework is critical to productive system-level programming in C and C++. Follow the same process as in the previous discussion section. You need to login to a workstation with your NetID and password. Start a terminal and then don't forget to source the setup script! 1 % source setup-ece2400.sh Now clone the github repo for this discussion section. 1 2 3 4 5 % mkdir -p ${ HOME } /ece2400 % cd ${ HOME } /ece2400 % git clone git@github.com:cornell-ece2400/ece2400-sec3-c-build-test sec3 % cd sec3/src % ls The given src directory includes the following files: avg-sfile.c : source and main for single-file avg program avg.h : header file for the avg function avg.c : source file for the avg function avg-mfile.c : main for multi-file avg program avg-mfile-basic-tests.h : most basic smoke test utst.h : simple C preprocessor macros for unit testing 1. Basic Makefile for Compiling C Programs Let's remind ourselves how to explicitly compile and run a single-file C program on the command line: 1 2 3 % cd ${ HOME } /ece2400/sec3/src % gcc -Wall -o avg-sfile avg-sfile.c % ./avg-sfile Let's now remove the binary so we are back to a clean directory: 1 2 % cd ${ HOME } /ece2400/sec3/src % rm -rf avg-sfile We will start by using a new tool called make which was specifically designed to help automate the process of building C programs. The key to using make is developing a Makefile . A Makefile is a plain text file which contains a list of rules which together specify how to execute commands to accomplish some task. Each rule has the following syntax: 1 2 target : prerequisite0 prerequisite1 prerequisite2 TAB command A rule specifies how to generate the target file using the list of prerequisite files and the given Linux command. make is smart enough to know it should rerun the command if any of the prerequisites change, and it also knows that if one of the prerequisites does not exist then it needs to look for some other rule to generate that prerequisite first. It is very important to note that make requires commands in a rule to start with a real TAB character. So you should not type the letters TAB , but you should instead press the TAB key and verify that it has inserted a real TAB character (i.e., if you move the left/right arrows the cursor should jump back and forth across the TAB). This is the only time in the course where you should use a real TAB character as opposed to spaces. Let's create a simple Makefile to compile a single-file C program. Use your favorite text editor to create a file named Makefile in the src directory with the following content: 1 2 3 4 5 avg-sfile : avg - sfile . c TAB gcc -Wall -o avg-sfile avg-sfile.c clean : TAB rm -rf avg-sfile We can use the newly created Makefile like this: 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make avg-sfile % ./avg-sfile make will by default use the Makefile in the current directory. make takes a command line argument specifying what you want \"make\". In this case, we want to make the avg-sfile executable. make will look at all of the rules in the Makefile to find a rule that specifies how to make the avg-sfile executable. It will then check to make sure the prerequisites exist and that they are up-to-date, and then it will run the command specified in the rule for avg-sfile . In this case, that command is gcc . make will output to the terminal every command it runs, so you should see it output the command line which uses gcc to generate the avg-sfile executable. Try running make again: 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make avg-sfile % ./avg-sfile make detects that the prerequisite (i.e., avg-sfile.c ) has not changed and so it does not recompile the executable. Now let's try making a change in the avg-sfile.c source file. Modify the printf statement as follows: 1 printf ( avg( %d, %d ) == %d \\n , a , b , c ); You can recompile and re-execute the program like this: 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make avg-sfile % ./avg-sfile make will automatically detect that the prerequisite has changed and recompile the executable appropriately. This ability to automatically track dependencies and recompile just what is necessary is a key benefit of using a tool like make . Makefiles can also include targets which are not actually files. Our example Makefile includes a clean target which will delete any generated executables. Let's clean up our directory like this: 1 2 3 4 % cd ${ HOME } /ece2400/sec3/src % ls % make clean % ls To-Do On Your Own Add two rules to your Makefile to compile avg.o and avg-mfile.o . Add a rule that links these two object files together and produces avg-mfile . Update the rule for the clean target appropriately. Carefully consider what command and prerequisites to use for each target. Test out your Makefile . Try changing avg.c and rerunning make . Does your program recompile correctly? Try changing avg.h and rerunning make . Does your program recompile correctly? 2. Using CMake to Generate Makefiles for Compiling C Programs While using make can help automate the build process, the corresponding Makefiles can quickly grow to be incredibly complicated. Creating and maintaining these Makefiles can involve significant effort. It can be particularly challenging to ensure all of the dependencies between the various source and header files are always correctly captured in the Makefile . It can also be complicated to add support for code coverage, memory checking, and debug vs.~evaluation builds. New tools have been developed to help automate the process of managing Makefiles (which in turn automate the build process). Automation is the key to effective software development methodologies. In this course, we will be using CMake as a key step in our build framework. CMake takes as input a simple CMakeLists.txt file and generates a sophisticated Makefile for us to use. A CMakeLists.txt is a plain text file with a list of commands that specify what tasks we would like the generated Makefile to perform. Before getting started let's remove any files we have generated and also remove the Makefile we developed in the previous section. 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make clean % trash Makefile Let's create a simple CMakeLists.txt that can be used to generate a Makefile which will in turn be used to compile a single-file C program. User your favorite text editor to create a file named CMakeLists.txt in the src directory with the following content: 1 2 3 cmake_minimum_required ( VERSION 2.8 ) enable_language ( C ) add_executable ( avg-sfile avg-sfile.c ) Line 1 specifies the CMake version we are assuming, and line 2 specifies that we will be using CMake with a C project. Line 3 specifies that we want to generate a Makefile that can compile an executable named avg-sfile form the avg-sfile.c source file. Now let's run the cmake command to generate a Makefile we can use to compile avg-sfile : 1 2 3 4 % cd ${ HOME } /ece2400/sec3/src % cmake . % ls % less Makefile The cmake command will by default use the CMakeLists.txt in the directory given as a command line argument. CMake takes care of figuring out what C compilers are available and then generating the Makefile appropriately. You can see that CMake has automatically generated a pretty sophisticated Makefile . Let's go ahead and use this Makefile to build avg-sfile . 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make avg-sfile % ./avg-sfile CMake will automatically create some useful targets like clean . 1 2 % cd ${ HOME } /ece2400/sec3/src % make clean Writing a CMakeLists.txt is simpler than writing a Makefile , especially when we start working with many files. To-Do On Your Own Add another line to your CMakeLists.txt file to specify that we want to generate a Makefile that can be used to compile avg-mfile from avg-mfile.c and avg.c . Use CMake to generate the corresponding Makefile and then use make to compile avg-mfile . Try changing avg.c and rerunning make . Does your program recompile correctly? Try changing avg.h and rerunning make . Does your program recompile correctly? 3. Using CTest for Systematic Unit Testing So far we have been using \"ad-hoc testing\". For example, the main function in avg-sfile.c will execute the avg function with one set of inputs and then print the result to the terminal. If it is not what we expected, we can debug our program until it meets our expectations. Unfortunately, ad-hoc testing is error prone and not easily reproducible. If you later make a change to your implementation, you would have to take another look at the output to ensure your implementation still works. If another developer wants to understand your implementation and verify that it is working, he or she would also need to take a look at the output and think hard about what is the expected result. Ad-hoc testing is usually verbose, which makes it error prone, and does not use any kind of standard test output. While ad-hoc testing might be feasible for very simple implementations, it is obviously not a scalable approach when developing the more complicated implementations we will tackle in this course. New tools have been developed to help automate the process of testing implementations. These tools provide a systematic way to do automated unit testing including standardized naming conventions, test output, and test drivers. In this course, we will be using CTest as a key step in our test framework. CTest elegantly integrates with CMake to create a unified built and test framework. Each unit test will be a stand-alone test program where the test code is contained within the main function. The following is an example of a unit test program for our avg function: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include stdio.h #include avg.h #include utst.h int main () { UTST_BEGIN (); UTST_ASSERT_INT_EQ ( avg ( 10 , 20 ), 15 ); UTST_END (); return 0 ; } We provide a simple library of test macros in utst.h which can be used to write various testing assertions. You should always insert UTST_BEGIN() at the beginning of main and UTST_END() at the end of main immediately before the final return statement. The UTST_ASSERT_INT_EQ macro asserts that the two given integer parameters are equal. If they are indeed equal, then the macro prints out the values, and we move on to the next test assertion. If they are not equal, the the macro prints out an error message and returns from main with the value 1. Recall that when main returns 0 it means success, and when main returns 1 it means failure. The return value enables our test program to inform CTest of whether or not our test passed of failed. We have provided the above test program in the repository for this discussion section. To use CTest, we need to tell it about this new test program. We can do this by simply adding a new line to our CMakeLists.txt file. Here is an example CMakeLists.txt file: 1 2 3 4 5 6 7 8 9 cmake_minimum_required ( VERSION 2.8 ) enable_language ( C ) enable_testing () add_executable ( avg-sfile avg-sfile.c ) add_executable ( avg-mfile avg-mfile.c avg.c ) add_executable ( avg-mfile-basic-tests avg-mfile-basic-tests.c avg.c ) add_test ( avg-mfile-basic-tests avg-mfile-basic-tests ) Line 3 tells CMake to turn on support for testing with CTest. Line 6 specifies how to build avg-mfile . Line 8 specifies how to build the avg-mfile-basic-tests test program. Line 9 tells CMake that avg-mfile-basic-tests is a test that should be managed by CTest. Modify your CMakeLists.txt file to look like what is given above, rerun cmake, build the test, and run it. 1 2 3 4 % cd ${ HOME } /ece2400/sec3/src % cmake . % make avg-mfile-basic-tests % ./avg-mfile-basic-tests You should see some output which indicates the passing test assertion. CMake provides a test target which can run all of the tests and provides a summary. 1 2 % cd ${ HOME } /ece2400/sec3/src % make test It is always a good idea to occasionally force a test to fail to ensure your test framework is behaving correctly. Change the test assertion in avg-mfile-basic-tests.c to look like this: 1 UTST_ASSERT_INT_EQ ( avg ( 10 , 20 ), 16 ); Then rebuild and rerun the test like this: 1 2 3 4 % cd ${ HOME } /ece2400/sec3/src % make avg-mfile-basic-tests % make test % ./avg-mfile-basic-tests You should see the test failing in the test summary, and then see additional information about the failing test assertion when you explicitly run the test program. avg-mfile-basic-tests is a kind of \"smoke\" test which is used to test the absolute most basic functionality of an implementation. We will also be doing extensive directed testing and random testing . In directed testing, you explicitly use test assertions to test as many corner cases as possible. In random testing, you use random input values and compare the output to some golden \"reference\" implementation to hopefully catch bugs missed in your directed testing. To-Do On Your Own Create another unit test program named avg-mfile-directed-tests.c for directed testing. Use the macros in utst.h to begin/end your test program and for test assertions. Try to test several different corner cases. Modify your CMakeLists.txt file to include this new unit test program. Use CMake to regenerate the corresponding Makefile , use make to build your test program, and then run it. Ensure that make test runs both the basic and directed tests. 4. Using a Build Directory Take a look at the source directory. It likely contains a mess of generated directories, object files, executables, etc. It is usually very bad practice to build C programs directly in the source directory. It is much better to build C programs in a completely separate build directory. Adding support for these build directories in a Makefile is complex, but CMake makes it easy. Let's start by deleting all generated content in your source directory: 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make clean % trash CMakeCache.txt CMakeFiles *.cmake Now let's first create a separate build directory, use CMake to create a new Makefile , and finally build and run all of our tests. 1 2 3 4 5 6 % cd ${ HOME } /ece2400/sec3 % mkdir build % cd build % cmake ../src % make % make test A separate build directory makes it easy to do a \"clean build\" where you start your build from scratch. Simply remove the build directory and start again like this: 1 2 3 4 5 6 7 % cd ${ HOME } /ece2400/sec3 % trash build % mkdir build % cd build % cmake ../src % make % make test You should never check in your build directory or any generated content into Git. Only source files are checked into Git! To-Do On Your Own Add a new test assertion to your directed tests. Rebuild and rerun the test program in the separate build directory. 5. Try Steps for Programming Assignments For each programming assignment, we will provide you a skeleton for your project including a complete CMakeLists.txt . In the common case, you should not need to modify the CMakeLists.txt unless you want to incorporate additional source and/or test files. The programming assignments are setup to use a separate build directory. The programming assignments also group all of the tests into their own separate directory. You can use the following steps to clone and build the first programming assignment. 1 2 3 4 5 6 7 8 9 10 % mkdir -p ${ HOME } /ece2400 % cd ece2400 % git clone git@github.com:cornell-ece2400/netid % cd ece2400-pa-release/pa1-math % tree % mkdir build % cd build % cmake .. % make % make test Where netid is your NetID. We provide you convenient check targets which should be the primary way you build and run your tests. These targets take care of making sure your test programs are always up-to-date before running them. The following will run all of the tests for the first programming assignment: 1 2 % cd ${ HOME } /ece2400/netid/pa1-math/build % make check If there is a test failure, we can \"zoom in\" and run just the tests for the corresponding implementation like this: 1 2 % cd ${ HOME } /ece2400/netid/pa1-math/build % make check-pow-iter Then we can \"zoom in\" further, and run a single test program so we can see exactly which test assertion is failing. We should always start by debugging the simplest test program first (i.e., basic tests) before moving on to directed or random tests. 1 2 % cd ${ HOME } /ece2400/netid/pa1-math/build % make check-pow-iter-basic-tests Once we fix the bug, then we can \"zoom out\" and move on to the next failing test program, or to the next implementation. To-Do On Your Own Force one of your directed test assertions to fail. Use the check targets to \"zoom in\", fix the bug, and then \"zoom out\".","title":"Section 3: C Build and Test Frameworks"},{"location":"ece2400-sec3-c-build-test/#section-3-c-build-and-test-frameworks","text":"In the previous discussion section, you learned how to explicitly compile and run C programs from the command line. You learned how to use the GNU C Compiler ( gcc ) to compile both a single-file and multi-file program that calculated the average of two integers. You probably noticed that it can be tedious to have to carefully enter the correct commands on the command line. We also need to carefully track which steps need to be redone whenever we change a C source file. In this discussion section, we will explore using a build framework based on CMake to automate this process. In the previous discussion section, you also learned how to do ad-hoc testing by executing a function and then simply printing out the result to the terminal. In this discussion section, we will explore using a test framework to automate this process. Using a build and test framework is critical to productive system-level programming in C and C++. Follow the same process as in the previous discussion section. You need to login to a workstation with your NetID and password. Start a terminal and then don't forget to source the setup script! 1 % source setup-ece2400.sh Now clone the github repo for this discussion section. 1 2 3 4 5 % mkdir -p ${ HOME } /ece2400 % cd ${ HOME } /ece2400 % git clone git@github.com:cornell-ece2400/ece2400-sec3-c-build-test sec3 % cd sec3/src % ls The given src directory includes the following files: avg-sfile.c : source and main for single-file avg program avg.h : header file for the avg function avg.c : source file for the avg function avg-mfile.c : main for multi-file avg program avg-mfile-basic-tests.h : most basic smoke test utst.h : simple C preprocessor macros for unit testing","title":"Section 3: C Build and Test Frameworks"},{"location":"ece2400-sec3-c-build-test/#1-basic-makefile-for-compiling-c-programs","text":"Let's remind ourselves how to explicitly compile and run a single-file C program on the command line: 1 2 3 % cd ${ HOME } /ece2400/sec3/src % gcc -Wall -o avg-sfile avg-sfile.c % ./avg-sfile Let's now remove the binary so we are back to a clean directory: 1 2 % cd ${ HOME } /ece2400/sec3/src % rm -rf avg-sfile We will start by using a new tool called make which was specifically designed to help automate the process of building C programs. The key to using make is developing a Makefile . A Makefile is a plain text file which contains a list of rules which together specify how to execute commands to accomplish some task. Each rule has the following syntax: 1 2 target : prerequisite0 prerequisite1 prerequisite2 TAB command A rule specifies how to generate the target file using the list of prerequisite files and the given Linux command. make is smart enough to know it should rerun the command if any of the prerequisites change, and it also knows that if one of the prerequisites does not exist then it needs to look for some other rule to generate that prerequisite first. It is very important to note that make requires commands in a rule to start with a real TAB character. So you should not type the letters TAB , but you should instead press the TAB key and verify that it has inserted a real TAB character (i.e., if you move the left/right arrows the cursor should jump back and forth across the TAB). This is the only time in the course where you should use a real TAB character as opposed to spaces. Let's create a simple Makefile to compile a single-file C program. Use your favorite text editor to create a file named Makefile in the src directory with the following content: 1 2 3 4 5 avg-sfile : avg - sfile . c TAB gcc -Wall -o avg-sfile avg-sfile.c clean : TAB rm -rf avg-sfile We can use the newly created Makefile like this: 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make avg-sfile % ./avg-sfile make will by default use the Makefile in the current directory. make takes a command line argument specifying what you want \"make\". In this case, we want to make the avg-sfile executable. make will look at all of the rules in the Makefile to find a rule that specifies how to make the avg-sfile executable. It will then check to make sure the prerequisites exist and that they are up-to-date, and then it will run the command specified in the rule for avg-sfile . In this case, that command is gcc . make will output to the terminal every command it runs, so you should see it output the command line which uses gcc to generate the avg-sfile executable. Try running make again: 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make avg-sfile % ./avg-sfile make detects that the prerequisite (i.e., avg-sfile.c ) has not changed and so it does not recompile the executable. Now let's try making a change in the avg-sfile.c source file. Modify the printf statement as follows: 1 printf ( avg( %d, %d ) == %d \\n , a , b , c ); You can recompile and re-execute the program like this: 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make avg-sfile % ./avg-sfile make will automatically detect that the prerequisite has changed and recompile the executable appropriately. This ability to automatically track dependencies and recompile just what is necessary is a key benefit of using a tool like make . Makefiles can also include targets which are not actually files. Our example Makefile includes a clean target which will delete any generated executables. Let's clean up our directory like this: 1 2 3 4 % cd ${ HOME } /ece2400/sec3/src % ls % make clean % ls To-Do On Your Own Add two rules to your Makefile to compile avg.o and avg-mfile.o . Add a rule that links these two object files together and produces avg-mfile . Update the rule for the clean target appropriately. Carefully consider what command and prerequisites to use for each target. Test out your Makefile . Try changing avg.c and rerunning make . Does your program recompile correctly? Try changing avg.h and rerunning make . Does your program recompile correctly?","title":"1. Basic Makefile for Compiling C Programs"},{"location":"ece2400-sec3-c-build-test/#2-using-cmake-to-generate-makefiles-for-compiling-c-programs","text":"While using make can help automate the build process, the corresponding Makefiles can quickly grow to be incredibly complicated. Creating and maintaining these Makefiles can involve significant effort. It can be particularly challenging to ensure all of the dependencies between the various source and header files are always correctly captured in the Makefile . It can also be complicated to add support for code coverage, memory checking, and debug vs.~evaluation builds. New tools have been developed to help automate the process of managing Makefiles (which in turn automate the build process). Automation is the key to effective software development methodologies. In this course, we will be using CMake as a key step in our build framework. CMake takes as input a simple CMakeLists.txt file and generates a sophisticated Makefile for us to use. A CMakeLists.txt is a plain text file with a list of commands that specify what tasks we would like the generated Makefile to perform. Before getting started let's remove any files we have generated and also remove the Makefile we developed in the previous section. 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make clean % trash Makefile Let's create a simple CMakeLists.txt that can be used to generate a Makefile which will in turn be used to compile a single-file C program. User your favorite text editor to create a file named CMakeLists.txt in the src directory with the following content: 1 2 3 cmake_minimum_required ( VERSION 2.8 ) enable_language ( C ) add_executable ( avg-sfile avg-sfile.c ) Line 1 specifies the CMake version we are assuming, and line 2 specifies that we will be using CMake with a C project. Line 3 specifies that we want to generate a Makefile that can compile an executable named avg-sfile form the avg-sfile.c source file. Now let's run the cmake command to generate a Makefile we can use to compile avg-sfile : 1 2 3 4 % cd ${ HOME } /ece2400/sec3/src % cmake . % ls % less Makefile The cmake command will by default use the CMakeLists.txt in the directory given as a command line argument. CMake takes care of figuring out what C compilers are available and then generating the Makefile appropriately. You can see that CMake has automatically generated a pretty sophisticated Makefile . Let's go ahead and use this Makefile to build avg-sfile . 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make avg-sfile % ./avg-sfile CMake will automatically create some useful targets like clean . 1 2 % cd ${ HOME } /ece2400/sec3/src % make clean Writing a CMakeLists.txt is simpler than writing a Makefile , especially when we start working with many files. To-Do On Your Own Add another line to your CMakeLists.txt file to specify that we want to generate a Makefile that can be used to compile avg-mfile from avg-mfile.c and avg.c . Use CMake to generate the corresponding Makefile and then use make to compile avg-mfile . Try changing avg.c and rerunning make . Does your program recompile correctly? Try changing avg.h and rerunning make . Does your program recompile correctly?","title":"2. Using CMake to Generate Makefiles for Compiling C Programs"},{"location":"ece2400-sec3-c-build-test/#3-using-ctest-for-systematic-unit-testing","text":"So far we have been using \"ad-hoc testing\". For example, the main function in avg-sfile.c will execute the avg function with one set of inputs and then print the result to the terminal. If it is not what we expected, we can debug our program until it meets our expectations. Unfortunately, ad-hoc testing is error prone and not easily reproducible. If you later make a change to your implementation, you would have to take another look at the output to ensure your implementation still works. If another developer wants to understand your implementation and verify that it is working, he or she would also need to take a look at the output and think hard about what is the expected result. Ad-hoc testing is usually verbose, which makes it error prone, and does not use any kind of standard test output. While ad-hoc testing might be feasible for very simple implementations, it is obviously not a scalable approach when developing the more complicated implementations we will tackle in this course. New tools have been developed to help automate the process of testing implementations. These tools provide a systematic way to do automated unit testing including standardized naming conventions, test output, and test drivers. In this course, we will be using CTest as a key step in our test framework. CTest elegantly integrates with CMake to create a unified built and test framework. Each unit test will be a stand-alone test program where the test code is contained within the main function. The following is an example of a unit test program for our avg function: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include stdio.h #include avg.h #include utst.h int main () { UTST_BEGIN (); UTST_ASSERT_INT_EQ ( avg ( 10 , 20 ), 15 ); UTST_END (); return 0 ; } We provide a simple library of test macros in utst.h which can be used to write various testing assertions. You should always insert UTST_BEGIN() at the beginning of main and UTST_END() at the end of main immediately before the final return statement. The UTST_ASSERT_INT_EQ macro asserts that the two given integer parameters are equal. If they are indeed equal, then the macro prints out the values, and we move on to the next test assertion. If they are not equal, the the macro prints out an error message and returns from main with the value 1. Recall that when main returns 0 it means success, and when main returns 1 it means failure. The return value enables our test program to inform CTest of whether or not our test passed of failed. We have provided the above test program in the repository for this discussion section. To use CTest, we need to tell it about this new test program. We can do this by simply adding a new line to our CMakeLists.txt file. Here is an example CMakeLists.txt file: 1 2 3 4 5 6 7 8 9 cmake_minimum_required ( VERSION 2.8 ) enable_language ( C ) enable_testing () add_executable ( avg-sfile avg-sfile.c ) add_executable ( avg-mfile avg-mfile.c avg.c ) add_executable ( avg-mfile-basic-tests avg-mfile-basic-tests.c avg.c ) add_test ( avg-mfile-basic-tests avg-mfile-basic-tests ) Line 3 tells CMake to turn on support for testing with CTest. Line 6 specifies how to build avg-mfile . Line 8 specifies how to build the avg-mfile-basic-tests test program. Line 9 tells CMake that avg-mfile-basic-tests is a test that should be managed by CTest. Modify your CMakeLists.txt file to look like what is given above, rerun cmake, build the test, and run it. 1 2 3 4 % cd ${ HOME } /ece2400/sec3/src % cmake . % make avg-mfile-basic-tests % ./avg-mfile-basic-tests You should see some output which indicates the passing test assertion. CMake provides a test target which can run all of the tests and provides a summary. 1 2 % cd ${ HOME } /ece2400/sec3/src % make test It is always a good idea to occasionally force a test to fail to ensure your test framework is behaving correctly. Change the test assertion in avg-mfile-basic-tests.c to look like this: 1 UTST_ASSERT_INT_EQ ( avg ( 10 , 20 ), 16 ); Then rebuild and rerun the test like this: 1 2 3 4 % cd ${ HOME } /ece2400/sec3/src % make avg-mfile-basic-tests % make test % ./avg-mfile-basic-tests You should see the test failing in the test summary, and then see additional information about the failing test assertion when you explicitly run the test program. avg-mfile-basic-tests is a kind of \"smoke\" test which is used to test the absolute most basic functionality of an implementation. We will also be doing extensive directed testing and random testing . In directed testing, you explicitly use test assertions to test as many corner cases as possible. In random testing, you use random input values and compare the output to some golden \"reference\" implementation to hopefully catch bugs missed in your directed testing. To-Do On Your Own Create another unit test program named avg-mfile-directed-tests.c for directed testing. Use the macros in utst.h to begin/end your test program and for test assertions. Try to test several different corner cases. Modify your CMakeLists.txt file to include this new unit test program. Use CMake to regenerate the corresponding Makefile , use make to build your test program, and then run it. Ensure that make test runs both the basic and directed tests.","title":"3. Using CTest for Systematic Unit Testing"},{"location":"ece2400-sec3-c-build-test/#4-using-a-build-directory","text":"Take a look at the source directory. It likely contains a mess of generated directories, object files, executables, etc. It is usually very bad practice to build C programs directly in the source directory. It is much better to build C programs in a completely separate build directory. Adding support for these build directories in a Makefile is complex, but CMake makes it easy. Let's start by deleting all generated content in your source directory: 1 2 3 % cd ${ HOME } /ece2400/sec3/src % make clean % trash CMakeCache.txt CMakeFiles *.cmake Now let's first create a separate build directory, use CMake to create a new Makefile , and finally build and run all of our tests. 1 2 3 4 5 6 % cd ${ HOME } /ece2400/sec3 % mkdir build % cd build % cmake ../src % make % make test A separate build directory makes it easy to do a \"clean build\" where you start your build from scratch. Simply remove the build directory and start again like this: 1 2 3 4 5 6 7 % cd ${ HOME } /ece2400/sec3 % trash build % mkdir build % cd build % cmake ../src % make % make test You should never check in your build directory or any generated content into Git. Only source files are checked into Git! To-Do On Your Own Add a new test assertion to your directed tests. Rebuild and rerun the test program in the separate build directory.","title":"4. Using a Build Directory"},{"location":"ece2400-sec3-c-build-test/#5-try-steps-for-programming-assignments","text":"For each programming assignment, we will provide you a skeleton for your project including a complete CMakeLists.txt . In the common case, you should not need to modify the CMakeLists.txt unless you want to incorporate additional source and/or test files. The programming assignments are setup to use a separate build directory. The programming assignments also group all of the tests into their own separate directory. You can use the following steps to clone and build the first programming assignment. 1 2 3 4 5 6 7 8 9 10 % mkdir -p ${ HOME } /ece2400 % cd ece2400 % git clone git@github.com:cornell-ece2400/netid % cd ece2400-pa-release/pa1-math % tree % mkdir build % cd build % cmake .. % make % make test Where netid is your NetID. We provide you convenient check targets which should be the primary way you build and run your tests. These targets take care of making sure your test programs are always up-to-date before running them. The following will run all of the tests for the first programming assignment: 1 2 % cd ${ HOME } /ece2400/netid/pa1-math/build % make check If there is a test failure, we can \"zoom in\" and run just the tests for the corresponding implementation like this: 1 2 % cd ${ HOME } /ece2400/netid/pa1-math/build % make check-pow-iter Then we can \"zoom in\" further, and run a single test program so we can see exactly which test assertion is failing. We should always start by debugging the simplest test program first (i.e., basic tests) before moving on to directed or random tests. 1 2 % cd ${ HOME } /ece2400/netid/pa1-math/build % make check-pow-iter-basic-tests Once we fix the bug, then we can \"zoom out\" and move on to the next failing test program, or to the next implementation. To-Do On Your Own Force one of your directed test assertions to fail. Use the check targets to \"zoom in\", fix the bug, and then \"zoom out\".","title":"5. Try Steps for Programming Assignments"},{"location":"ece2400-tut1-linux-git/","text":"Tutorial 1: Linux and Git","title":"Ece2400 tut1 linux git"},{"location":"ece2400-tut1-linux-git/#tutorial-1-linux-and-git","text":"","title":"Tutorial 1: Linux and Git"},{"location":"ece2400-tut2-c-basics/","text":"Tutorial 2 : Compiling and Running C Programs The first few programming assignments for this course will use the C programming language. In lecture we use Compiler Explorer and Repl.it to quickly experiment with small C programs, but eventually we need to actually write and compile C programs on a real machine. This tutorial discusses how we can use the open-source GNU C compiler ( gcc ) to compile our C programs on the \\TT{ecelinux} machines. We will experiment with both single-file C programs (simple but not representative of real C projects) and multi-file programs (more complex but also more realistic). In this tutorial, we will be running \\TT{gcc} directly from the command line so we can understand each step. In the next tutorial, we will see how we can use various tools to automate this process. All of the tools are installed and available on the ecelinux machines. This tutorial assumes that students have completed the tutorial on Linux and Git. We strongly recommend students also read Chapters 1-6 in the course text book, ``All of Programming,'' by A. Hilton and A. Bracy (2015). Chapters 5-6 are particularly relevant since they discuss the general process of compiling, testing, and debugging C programs. To follow along with the tutorial, access the course computing resources, and type the commands without the % character (for the bash prompt). In addition to working through the commands in the tutorial, you should also try the more open-ended tasks marked To-Do On Your Own . Before you begin, make sure that you have sourced the setup-ece2400.sh script or that you have added it to your .bashrc script, which will then source the script every time you login. Sourcing the setup script sets up the environment required for this class. You should start by forking the tutorial repository on GitHub. Go to the GitHub page for the tutorial repository located here: https://github.com/cornell-ece2400/ece2400-tut2-c-basics . Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a new repository in your account: https://github.com/githubid/ece2400-tut2-c-basics Where githubid is your GitHub username on github.com . Now access an ecelinux machine and clone your copy of the tutorial repository as follows: 1 2 3 4 5 6 % source setup-ece2400.sh % mkdir -p ${ HOME } /ece2400 % cd ${ HOME } /ece2400 % git clone https://github.com/githubid/ece2400-tut3-c-basics.git tut3 % cd tut3 % TUTROOT = ${ PWD } Note It should be possible to experiment with this tutorial even if you are not enrolled in the course and/or do not have access to the course computing resources. All of the code for the tutorial is located on GitHub. You will not use the setup-ece2400.sh script, and your specific environment may be different from what is assumed in this tutorial. 1. Using the C Preprocessor Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocesor is not really part of the C programming language. The C preprocessor simply manipulates the text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. You can find out more about the C preprocessor here: http://en.cppreference.com/w/c/preprocessor https://en.wikibooks.org/wiki/C_Programming/Preprocessor 1.1. The #define Directive The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we are writing a report on the history of Cornell University, and we have a common snippet of text that we use often in our text file. text with many of same code define that mention ALL_CAPS define with argument try to avoid this -- will see it in our test macros 1.2. The #ifdef Directive 1.3. The #include Directive The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we wish to create a text file which lists pioneering women and men in the field of computer science. We might start with a text file of pioneering women: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation and a separate text file of pioneering men: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer These two files require some duplication, since both files include a short introductory paragraph. To avoid this redundancy, we can first refactor this introductory paragraph into its own dedicated text file, and we can then use the C processor to include this file at the beginning of each list of pioneers. This new approach is illustrated below. First, we have a file named cs-pioneers-intro.txt with the introductory paragraph. 1 2 3 4 5 6 7 8 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. Then, we have a file named cs-pioneers-women-in.txt containing a list of pioneering women in computer science: 1 2 3 4 5 6 7 8 9 #include cs-pioneers-intro.txt - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation Finally, we have a file named cs-pioneers-men-in.txt containing a list of pioneering men in computer science: 1 2 3 4 5 6 7 8 9 #include cs-pioneers-intro.txt - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer We can then use the C preprocessor to preprocess these files. The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. Line 1 in cs-pioneers-women-in.txt and cs-pioneers-men-in.txt uses the #include directive which specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). You should have already cloned the tutorial repository and set the TUTROOT environment variable at the beginning of this tutorial. Let's make a new directory to work in for this section: 1 2 % mkdir ${ TUTROOT } /tut3-cpp % cd ${ TUTROOT } /tut3-cpp Now create the three text files mentioned above: cs-pioneers-intro.txt , cs-pioneers-women-in.txt , and cs-pioneers-men-in.txt using Geany or the text editor of your choice. See the first tutorial for more on using Geany or other text editors. The three files should be in the tut3-cpp subdirectory. All text files have a .txt filename extension. In general, we prefer using dashes ( - ) instead of underscores to separate words in file names. Let's use the C preprocessor ( cpp ) to preprocess the -in.txt files into two final text files that contain both the introductory paragraph and the list of pionners in computer science. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt The -o command line option is used to specify the name of the output file. The outpfile cs-pioneers-women.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 1 cs-pioneers-women-in.txt # 1 built-in # 1 command-line # 1 cs-pioneers-women-in.txt # 1 cs-pioneers-intro.txt 1 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. # 2 cs-pioneers-women-in.txt 2 - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation The C preprocessor included the introductory paragraph correctly, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. For example, Line 5 indicates that the introductory paragraph came from the cs-pioneers-intro.txt file. We can tell the cpp to not include this extra metadata with the -P command line option. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -P -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -P -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor in the previous section when we included the \\TT{stdio.h} header file which includes the declaration of the \\TT{printf} function (see Line~1 in Figure~\\ref{fig-tut3-code-avg-main}). If the file in an \\verb|#include| directive is specified using angle brackets (\\TT{ }) then this tells the C preprocessor that the file to include is part of the system and is installed in a default location. If the given file is specified using double quotes (\\TT{\"\"}), then this tells the C preprocessor that the file to be included is part of the user program. The C preprocessor does not automatically know where to find extra user files, so we might need to add extra command line options to \\TT{cpp} to tell the C preprocessor where to search for files. 1.4. Include Guards 2. Writing a Single-File C Program 3. Compiling a Single-File C Program 4. Writing a Multi-File C Program 5. Compiling a Multi-File C Program","title":"Ece2400 tut2 c basics"},{"location":"ece2400-tut2-c-basics/#tutorial-2-compiling-and-running-c-programs","text":"The first few programming assignments for this course will use the C programming language. In lecture we use Compiler Explorer and Repl.it to quickly experiment with small C programs, but eventually we need to actually write and compile C programs on a real machine. This tutorial discusses how we can use the open-source GNU C compiler ( gcc ) to compile our C programs on the \\TT{ecelinux} machines. We will experiment with both single-file C programs (simple but not representative of real C projects) and multi-file programs (more complex but also more realistic). In this tutorial, we will be running \\TT{gcc} directly from the command line so we can understand each step. In the next tutorial, we will see how we can use various tools to automate this process. All of the tools are installed and available on the ecelinux machines. This tutorial assumes that students have completed the tutorial on Linux and Git. We strongly recommend students also read Chapters 1-6 in the course text book, ``All of Programming,'' by A. Hilton and A. Bracy (2015). Chapters 5-6 are particularly relevant since they discuss the general process of compiling, testing, and debugging C programs. To follow along with the tutorial, access the course computing resources, and type the commands without the % character (for the bash prompt). In addition to working through the commands in the tutorial, you should also try the more open-ended tasks marked To-Do On Your Own . Before you begin, make sure that you have sourced the setup-ece2400.sh script or that you have added it to your .bashrc script, which will then source the script every time you login. Sourcing the setup script sets up the environment required for this class. You should start by forking the tutorial repository on GitHub. Go to the GitHub page for the tutorial repository located here: https://github.com/cornell-ece2400/ece2400-tut2-c-basics . Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a new repository in your account: https://github.com/githubid/ece2400-tut2-c-basics Where githubid is your GitHub username on github.com . Now access an ecelinux machine and clone your copy of the tutorial repository as follows: 1 2 3 4 5 6 % source setup-ece2400.sh % mkdir -p ${ HOME } /ece2400 % cd ${ HOME } /ece2400 % git clone https://github.com/githubid/ece2400-tut3-c-basics.git tut3 % cd tut3 % TUTROOT = ${ PWD } Note It should be possible to experiment with this tutorial even if you are not enrolled in the course and/or do not have access to the course computing resources. All of the code for the tutorial is located on GitHub. You will not use the setup-ece2400.sh script, and your specific environment may be different from what is assumed in this tutorial.","title":"Tutorial 2 : Compiling and Running C Programs"},{"location":"ece2400-tut2-c-basics/#1-using-the-c-preprocessor","text":"Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocesor is not really part of the C programming language. The C preprocessor simply manipulates the text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. You can find out more about the C preprocessor here: http://en.cppreference.com/w/c/preprocessor https://en.wikibooks.org/wiki/C_Programming/Preprocessor","title":"1. Using the C Preprocessor"},{"location":"ece2400-tut2-c-basics/#11-the-define-directive","text":"The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we are writing a report on the history of Cornell University, and we have a common snippet of text that we use often in our text file. text with many of same code define that mention ALL_CAPS define with argument try to avoid this -- will see it in our test macros","title":"1.1. The #define Directive"},{"location":"ece2400-tut2-c-basics/#12-the-ifdef-directive","text":"","title":"1.2. The #ifdef Directive"},{"location":"ece2400-tut2-c-basics/#13-the-include-directive","text":"The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we wish to create a text file which lists pioneering women and men in the field of computer science. We might start with a text file of pioneering women: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation and a separate text file of pioneering men: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer These two files require some duplication, since both files include a short introductory paragraph. To avoid this redundancy, we can first refactor this introductory paragraph into its own dedicated text file, and we can then use the C processor to include this file at the beginning of each list of pioneers. This new approach is illustrated below. First, we have a file named cs-pioneers-intro.txt with the introductory paragraph. 1 2 3 4 5 6 7 8 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. Then, we have a file named cs-pioneers-women-in.txt containing a list of pioneering women in computer science: 1 2 3 4 5 6 7 8 9 #include cs-pioneers-intro.txt - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation Finally, we have a file named cs-pioneers-men-in.txt containing a list of pioneering men in computer science: 1 2 3 4 5 6 7 8 9 #include cs-pioneers-intro.txt - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer We can then use the C preprocessor to preprocess these files. The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. Line 1 in cs-pioneers-women-in.txt and cs-pioneers-men-in.txt uses the #include directive which specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). You should have already cloned the tutorial repository and set the TUTROOT environment variable at the beginning of this tutorial. Let's make a new directory to work in for this section: 1 2 % mkdir ${ TUTROOT } /tut3-cpp % cd ${ TUTROOT } /tut3-cpp Now create the three text files mentioned above: cs-pioneers-intro.txt , cs-pioneers-women-in.txt , and cs-pioneers-men-in.txt using Geany or the text editor of your choice. See the first tutorial for more on using Geany or other text editors. The three files should be in the tut3-cpp subdirectory. All text files have a .txt filename extension. In general, we prefer using dashes ( - ) instead of underscores to separate words in file names. Let's use the C preprocessor ( cpp ) to preprocess the -in.txt files into two final text files that contain both the introductory paragraph and the list of pionners in computer science. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt The -o command line option is used to specify the name of the output file. The outpfile cs-pioneers-women.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 1 cs-pioneers-women-in.txt # 1 built-in # 1 command-line # 1 cs-pioneers-women-in.txt # 1 cs-pioneers-intro.txt 1 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. # 2 cs-pioneers-women-in.txt 2 - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation The C preprocessor included the introductory paragraph correctly, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. For example, Line 5 indicates that the introductory paragraph came from the cs-pioneers-intro.txt file. We can tell the cpp to not include this extra metadata with the -P command line option. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -P -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -P -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor in the previous section when we included the \\TT{stdio.h} header file which includes the declaration of the \\TT{printf} function (see Line~1 in Figure~\\ref{fig-tut3-code-avg-main}). If the file in an \\verb|#include| directive is specified using angle brackets (\\TT{ }) then this tells the C preprocessor that the file to include is part of the system and is installed in a default location. If the given file is specified using double quotes (\\TT{\"\"}), then this tells the C preprocessor that the file to be included is part of the user program. The C preprocessor does not automatically know where to find extra user files, so we might need to add extra command line options to \\TT{cpp} to tell the C preprocessor where to search for files.","title":"1.3. The #include Directive"},{"location":"ece2400-tut2-c-basics/#14-include-guards","text":"","title":"1.4. Include Guards"},{"location":"ece2400-tut2-c-basics/#2-writing-a-single-file-c-program","text":"","title":"2. Writing a Single-File C Program"},{"location":"ece2400-tut2-c-basics/#3-compiling-a-single-file-c-program","text":"","title":"3. Compiling a Single-File C Program"},{"location":"ece2400-tut2-c-basics/#4-writing-a-multi-file-c-program","text":"","title":"4. Writing a Multi-File C Program"},{"location":"ece2400-tut2-c-basics/#5-compiling-a-multi-file-c-program","text":"","title":"5. Compiling a Multi-File C Program"},{"location":"ece2400-tut3-c-basics/","text":"Tutorial 3 : Compiling and Running C Programs The first few programming assignments for this course will use the C programming language. In lecture we use Compiler Explorer and Repl.it to quickly experiment with small C programs, but eventually we need to actually write and compile C programs on a real machine. This tutorial discusses how we can use the open-source GNU C compiler ( gcc ) to compile our C programs on the \\TT{ecelinux} machines. We will experiment with both single-file C programs (simple but not representative of real C projects) and multi-file programs (more complex but also more realistic). In this tutorial, we will be running \\TT{gcc} directly from the command line so we can understand each step. In the next tutorial, we will see how we can use various tools to automate this process. All of the tools are installed and available on the ecelinux machines. This tutorial assumes that students have completed the tutorial on Linux and Git. We strongly recommend students also read Chapters 1-6 in the course text book, ``All of Programming,'' by A. Hilton and A. Bracy (2015). Chapters 5-6 are particularly relevant since they discuss the general process of compiling, testing, and debugging C programs. To follow along with the tutorial, access the course computing resources, and type the commands without the % character (for the bash prompt). In addition to working through the commands in the tutorial, you should also try the more open-ended tasks marked To-Do On Your Own . Before you begin, make sure that you have sourced the setup-ece2400.sh script or that you have added it to your .bashrc script, which will then source the script every time you login. Sourcing the setup script sets up the environment required for this class. You should start by forking the tutorial repository on GitHub. Go to the GitHub page for the tutorial repository located here: https://github.com/cornell-ece2400/ece2400-tut2-c-basics . Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a new repository in your account: https://github.com/githubid/ece2400-tut2-c-basics Where githubid is your GitHub username on github.com . Now access an ecelinux machine and clone your copy of the tutorial repository as follows: 1 2 3 4 5 6 % source setup-ece2400.sh % mkdir -p ${ HOME } /ece2400 % cd ${ HOME } /ece2400 % git clone https://github.com/githubid/ece2400-tut3-c-basics.git tut3 % cd tut3 % TUTROOT = ${ PWD } Note It should be possible to experiment with this tutorial even if you are not enrolled in the course and/or do not have access to the course computing resources. All of the code for the tutorial is located on GitHub. You will not use the setup-ece2400.sh script, and your specific environment may be different from what is assumed in this tutorial. 1. Using the C Preprocessor Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocesor is not really part of the C programming language. The C preprocessor simply manipulates the text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. You can find out more about the C preprocessor here: http://en.cppreference.com/w/c/preprocessor https://en.wikibooks.org/wiki/C_Programming/Preprocessor 1.1. The #define Directive The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we are writing a report on the history of Cornell University, and we have a common snippet of text that we use often in our text file. text with many of same code define that mention ALL_CAPS define with argument try to avoid this -- will see it in our test macros 1.2. The #ifdef Directive 1.3. The #include Directive The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we wish to create a text file which lists pioneering women and men in the field of computer science. We might start with a text file of pioneering women: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation and a separate text file of pioneering men: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer These two files require some duplication, since both files include a short introductory paragraph. To avoid this redundancy, we can first refactor this introductory paragraph into its own dedicated text file, and we can then use the C processor to include this file at the beginning of each list of pioneers. This new approach is illustrated below. First, we have a file named cs-pioneers-intro.txt with the introductory paragraph. 1 2 3 4 5 6 7 8 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. Then, we have a file named cs-pioneers-women-in.txt containing a list of pioneering women in computer science: 1 2 3 4 5 6 7 8 9 #include cs-pioneers-intro.txt - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation Finally, we have a file named cs-pioneers-men-in.txt containing a list of pioneering men in computer science: 1 2 3 4 5 6 7 8 9 #include cs-pioneers-intro.txt - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer We can then use the C preprocessor to preprocess these files. The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. Line 1 in cs-pioneers-women-in.txt and cs-pioneers-men-in.txt uses the #include directive which specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). You should have already cloned the tutorial repository and set the TUTROOT environment variable at the beginning of this tutorial. Let's make a new directory to work in for this section: 1 2 % mkdir ${ TUTROOT } /tut3-cpp % cd ${ TUTROOT } /tut3-cpp Now create the three text files mentioned above: cs-pioneers-intro.txt , cs-pioneers-women-in.txt , and cs-pioneers-men-in.txt using Geany or the text editor of your choice. See the first tutorial for more on using Geany or other text editors. The three files should be in the tut3-cpp subdirectory. All text files have a .txt filename extension. In general, we prefer using dashes ( - ) instead of underscores to separate words in file names. Let's use the C preprocessor ( cpp ) to preprocess the -in.txt files into two final text files that contain both the introductory paragraph and the list of pionners in computer science. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt The -o command line option is used to specify the name of the output file. The outpfile cs-pioneers-women.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 1 cs-pioneers-women-in.txt # 1 built-in # 1 command-line # 1 cs-pioneers-women-in.txt # 1 cs-pioneers-intro.txt 1 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. # 2 cs-pioneers-women-in.txt 2 - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation The C preprocessor included the introductory paragraph correctly, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. For example, Line 5 indicates that the introductory paragraph came from the cs-pioneers-intro.txt file. We can tell the cpp to not include this extra metadata with the -P command line option. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -P -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -P -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor in the previous section when we included the \\TT{stdio.h} header file which includes the declaration of the \\TT{printf} function (see Line~1 in Figure~\\ref{fig-tut3-code-avg-main}). If the file in an \\verb|#include| directive is specified using angle brackets (\\TT{ }) then this tells the C preprocessor that the file to include is part of the system and is installed in a default location. If the given file is specified using double quotes (\\TT{\"\"}), then this tells the C preprocessor that the file to be included is part of the user program. The C preprocessor does not automatically know where to find extra user files, so we might need to add extra command line options to \\TT{cpp} to tell the C preprocessor where to search for files. 1.4. Include Guards 2. Writing a Single-File C Program 3. Compiling a Single-File C Program 4. Writing a Multi-File C Program 5. Compiling a Multi-File C Program","title":"Ece2400 tut3 c basics"},{"location":"ece2400-tut3-c-basics/#tutorial-3-compiling-and-running-c-programs","text":"The first few programming assignments for this course will use the C programming language. In lecture we use Compiler Explorer and Repl.it to quickly experiment with small C programs, but eventually we need to actually write and compile C programs on a real machine. This tutorial discusses how we can use the open-source GNU C compiler ( gcc ) to compile our C programs on the \\TT{ecelinux} machines. We will experiment with both single-file C programs (simple but not representative of real C projects) and multi-file programs (more complex but also more realistic). In this tutorial, we will be running \\TT{gcc} directly from the command line so we can understand each step. In the next tutorial, we will see how we can use various tools to automate this process. All of the tools are installed and available on the ecelinux machines. This tutorial assumes that students have completed the tutorial on Linux and Git. We strongly recommend students also read Chapters 1-6 in the course text book, ``All of Programming,'' by A. Hilton and A. Bracy (2015). Chapters 5-6 are particularly relevant since they discuss the general process of compiling, testing, and debugging C programs. To follow along with the tutorial, access the course computing resources, and type the commands without the % character (for the bash prompt). In addition to working through the commands in the tutorial, you should also try the more open-ended tasks marked To-Do On Your Own . Before you begin, make sure that you have sourced the setup-ece2400.sh script or that you have added it to your .bashrc script, which will then source the script every time you login. Sourcing the setup script sets up the environment required for this class. You should start by forking the tutorial repository on GitHub. Go to the GitHub page for the tutorial repository located here: https://github.com/cornell-ece2400/ece2400-tut2-c-basics . Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a new repository in your account: https://github.com/githubid/ece2400-tut2-c-basics Where githubid is your GitHub username on github.com . Now access an ecelinux machine and clone your copy of the tutorial repository as follows: 1 2 3 4 5 6 % source setup-ece2400.sh % mkdir -p ${ HOME } /ece2400 % cd ${ HOME } /ece2400 % git clone https://github.com/githubid/ece2400-tut3-c-basics.git tut3 % cd tut3 % TUTROOT = ${ PWD } Note It should be possible to experiment with this tutorial even if you are not enrolled in the course and/or do not have access to the course computing resources. All of the code for the tutorial is located on GitHub. You will not use the setup-ece2400.sh script, and your specific environment may be different from what is assumed in this tutorial.","title":"Tutorial 3 : Compiling and Running C Programs"},{"location":"ece2400-tut3-c-basics/#1-using-the-c-preprocessor","text":"Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocesor is not really part of the C programming language. The C preprocessor simply manipulates the text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. You can find out more about the C preprocessor here: http://en.cppreference.com/w/c/preprocessor https://en.wikibooks.org/wiki/C_Programming/Preprocessor","title":"1. Using the C Preprocessor"},{"location":"ece2400-tut3-c-basics/#11-the-define-directive","text":"The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we are writing a report on the history of Cornell University, and we have a common snippet of text that we use often in our text file. text with many of same code define that mention ALL_CAPS define with argument try to avoid this -- will see it in our test macros","title":"1.1. The #define Directive"},{"location":"ece2400-tut3-c-basics/#12-the-ifdef-directive","text":"","title":"1.2. The #ifdef Directive"},{"location":"ece2400-tut3-c-basics/#13-the-include-directive","text":"The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we wish to create a text file which lists pioneering women and men in the field of computer science. We might start with a text file of pioneering women: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation and a separate text file of pioneering men: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer These two files require some duplication, since both files include a short introductory paragraph. To avoid this redundancy, we can first refactor this introductory paragraph into its own dedicated text file, and we can then use the C processor to include this file at the beginning of each list of pioneers. This new approach is illustrated below. First, we have a file named cs-pioneers-intro.txt with the introductory paragraph. 1 2 3 4 5 6 7 8 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. Then, we have a file named cs-pioneers-women-in.txt containing a list of pioneering women in computer science: 1 2 3 4 5 6 7 8 9 #include cs-pioneers-intro.txt - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation Finally, we have a file named cs-pioneers-men-in.txt containing a list of pioneering men in computer science: 1 2 3 4 5 6 7 8 9 #include cs-pioneers-intro.txt - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer We can then use the C preprocessor to preprocess these files. The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. Line 1 in cs-pioneers-women-in.txt and cs-pioneers-men-in.txt uses the #include directive which specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). You should have already cloned the tutorial repository and set the TUTROOT environment variable at the beginning of this tutorial. Let's make a new directory to work in for this section: 1 2 % mkdir ${ TUTROOT } /tut3-cpp % cd ${ TUTROOT } /tut3-cpp Now create the three text files mentioned above: cs-pioneers-intro.txt , cs-pioneers-women-in.txt , and cs-pioneers-men-in.txt using Geany or the text editor of your choice. See the first tutorial for more on using Geany or other text editors. The three files should be in the tut3-cpp subdirectory. All text files have a .txt filename extension. In general, we prefer using dashes ( - ) instead of underscores to separate words in file names. Let's use the C preprocessor ( cpp ) to preprocess the -in.txt files into two final text files that contain both the introductory paragraph and the list of pionners in computer science. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt The -o command line option is used to specify the name of the output file. The outpfile cs-pioneers-women.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 1 cs-pioneers-women-in.txt # 1 built-in # 1 command-line # 1 cs-pioneers-women-in.txt # 1 cs-pioneers-intro.txt 1 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. # 2 cs-pioneers-women-in.txt 2 - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation The C preprocessor included the introductory paragraph correctly, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. For example, Line 5 indicates that the introductory paragraph came from the cs-pioneers-intro.txt file. We can tell the cpp to not include this extra metadata with the -P command line option. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -P -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -P -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor in the previous section when we included the \\TT{stdio.h} header file which includes the declaration of the \\TT{printf} function (see Line~1 in Figure~\\ref{fig-tut3-code-avg-main}). If the file in an \\verb|#include| directive is specified using angle brackets (\\TT{ }) then this tells the C preprocessor that the file to include is part of the system and is installed in a default location. If the given file is specified using double quotes (\\TT{\"\"}), then this tells the C preprocessor that the file to be included is part of the user program. The C preprocessor does not automatically know where to find extra user files, so we might need to add extra command line options to \\TT{cpp} to tell the C preprocessor where to search for files.","title":"1.3. The #include Directive"},{"location":"ece2400-tut3-c-basics/#14-include-guards","text":"","title":"1.4. Include Guards"},{"location":"ece2400-tut3-c-basics/#2-writing-a-single-file-c-program","text":"","title":"2. Writing a Single-File C Program"},{"location":"ece2400-tut3-c-basics/#3-compiling-a-single-file-c-program","text":"","title":"3. Compiling a Single-File C Program"},{"location":"ece2400-tut3-c-basics/#4-writing-a-multi-file-c-program","text":"","title":"4. Writing a Multi-File C Program"},{"location":"ece2400-tut3-c-basics/#5-compiling-a-multi-file-c-program","text":"","title":"5. Compiling a Multi-File C Program"}]}